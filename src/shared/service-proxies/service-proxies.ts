//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHello(): Observable<string> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHello(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetHello(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deploy(): Observable<boolean> {
        let url_ = this.baseUrl + "/deploy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeploy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeploy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeploy(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deloyweb(): Observable<boolean> {
        let url_ = this.baseUrl + "/deloyweb";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeloyweb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeloyweb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeloyweb(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieve a single FinancingScheme
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseFinancingSchemeControllerFinancingScheme(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<FinancingScheme> {
        let url_ = this.baseUrl + "/financing-scheme/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancingScheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancingScheme>;
        }));
    }

    protected processGetOneBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinancingScheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single FinancingScheme
     * @return Response
     */
    updateOneBaseFinancingSchemeControllerFinancingScheme(id: number, body: FinancingScheme): Observable<FinancingScheme> {
        let url_ = this.baseUrl + "/financing-scheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancingScheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancingScheme>;
        }));
    }

    protected processUpdateOneBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinancingScheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single FinancingScheme
     * @return Response
     */
    replaceOneBaseFinancingSchemeControllerFinancingScheme(id: number, body: FinancingScheme): Observable<FinancingScheme> {
        let url_ = this.baseUrl + "/financing-scheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancingScheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancingScheme>;
        }));
    }

    protected processReplaceOneBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinancingScheme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single FinancingScheme
     * @return Delete one base response
     */
    deleteOneBaseFinancingSchemeControllerFinancingScheme(id: number): Observable<void> {
        let url_ = this.baseUrl + "/financing-scheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple FinancingSchemes
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseFinancingSchemeControllerFinancingScheme(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyFinancingSchemeResponseDto> {
        let url_ = this.baseUrl + "/financing-scheme?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyFinancingSchemeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyFinancingSchemeResponseDto>;
        }));
    }

    protected processGetManyBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<GetManyFinancingSchemeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyFinancingSchemeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single FinancingScheme
     * @return Get create one base response
     */
    createOneBaseFinancingSchemeControllerFinancingScheme(body: FinancingScheme): Observable<FinancingScheme> {
        let url_ = this.baseUrl + "/financing-scheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancingScheme>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancingScheme>;
        }));
    }

    protected processCreateOneBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FinancingScheme.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple FinancingSchemes
     * @return Get create many base response
     */
    createManyBaseFinancingSchemeControllerFinancingScheme(body: BulkDto): Observable<FinancingScheme[]> {
        let url_ = this.baseUrl + "/financing-scheme/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseFinancingSchemeControllerFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseFinancingSchemeControllerFinancingScheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FinancingScheme[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FinancingScheme[]>;
        }));
    }

    protected processCreateManyBaseFinancingSchemeControllerFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(FinancingScheme.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single MethodologyData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMethodologyDataControllerMethodologyData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<MethodologyData> {
        let url_ = this.baseUrl + "/methodology-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MethodologyData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MethodologyData>;
        }));
    }

    protected processGetOneBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<MethodologyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MethodologyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single MethodologyData
     * @return Response
     */
    updateOneBaseMethodologyDataControllerMethodologyData(id: number, body: MethodologyData): Observable<MethodologyData> {
        let url_ = this.baseUrl + "/methodology-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MethodologyData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MethodologyData>;
        }));
    }

    protected processUpdateOneBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<MethodologyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MethodologyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single MethodologyData
     * @return Response
     */
    replaceOneBaseMethodologyDataControllerMethodologyData(id: number, body: MethodologyData): Observable<MethodologyData> {
        let url_ = this.baseUrl + "/methodology-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MethodologyData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MethodologyData>;
        }));
    }

    protected processReplaceOneBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<MethodologyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MethodologyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single MethodologyData
     * @return Delete one base response
     */
    deleteOneBaseMethodologyDataControllerMethodologyData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/methodology-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple MethodologyData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMethodologyDataControllerMethodologyData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMethodologyDataResponseDto> {
        let url_ = this.baseUrl + "/methodology-data?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMethodologyDataResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMethodologyDataResponseDto>;
        }));
    }

    protected processGetManyBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<GetManyMethodologyDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMethodologyDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single MethodologyData
     * @return Get create one base response
     */
    createOneBaseMethodologyDataControllerMethodologyData(body: MethodologyData): Observable<MethodologyData> {
        let url_ = this.baseUrl + "/methodology-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MethodologyData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MethodologyData>;
        }));
    }

    protected processCreateOneBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<MethodologyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MethodologyData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple MethodologyData
     * @return Get create many base response
     */
    createManyBaseMethodologyDataControllerMethodologyData(body: BulkDto): Observable<MethodologyData[]> {
        let url_ = this.baseUrl + "/methodology-data/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMethodologyDataControllerMethodologyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMethodologyDataControllerMethodologyData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MethodologyData[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MethodologyData[]>;
        }));
    }

    protected processCreateManyBaseMethodologyDataControllerMethodologyData(response: HttpResponseBase): Observable<MethodologyData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(MethodologyData.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Methodology
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMethodologyControllerMethodology(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processGetOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Methodology
     * @return Response
     */
    updateOneBaseMethodologyControllerMethodology(id: number, body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processUpdateOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Methodology
     * @return Response
     */
    replaceOneBaseMethodologyControllerMethodology(id: number, body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processReplaceOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Methodology.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Methodology
     * @return Delete one base response
     */
    deleteOneBaseMethodologyControllerMethodology(id: number): Observable<void> {
        let url_ = this.baseUrl + "/methodology/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Methodologies
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMethodologyControllerMethodology(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMethodologyResponseDto> {
        let url_ = this.baseUrl + "/methodology?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMethodologyResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMethodologyResponseDto>;
        }));
    }

    protected processGetManyBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<GetManyMethodologyResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMethodologyResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Methodology
     * @return Get create one base response
     */
    createOneBaseMethodologyControllerMethodology(body: Methodology): Observable<Methodology> {
        let url_ = this.baseUrl + "/methodology";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology>;
        }));
    }

    protected processCreateOneBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Methodology.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Methodologies
     * @return Get create many base response
     */
    createManyBaseMethodologyControllerMethodology(body: BulkDto): Observable<Methodology[]> {
        let url_ = this.baseUrl + "/methodology/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMethodologyControllerMethodology(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMethodologyControllerMethodology(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Methodology[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Methodology[]>;
        }));
    }

    protected processCreateManyBaseMethodologyControllerMethodology(response: HttpResponseBase): Observable<Methodology[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Methodology.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single EmissionReductioDraftDataEntity
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<EmissionReductioDraftDataEntity> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionReductioDraftDataEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionReductioDraftDataEntity>;
        }));
    }

    protected processGetOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<EmissionReductioDraftDataEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionReductioDraftDataEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single EmissionReductioDraftDataEntity
     * @return Response
     */
    updateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(id: number, body: EmissionReductioDraftDataEntity): Observable<EmissionReductioDraftDataEntity> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionReductioDraftDataEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionReductioDraftDataEntity>;
        }));
    }

    protected processUpdateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<EmissionReductioDraftDataEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionReductioDraftDataEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single EmissionReductioDraftDataEntity
     * @return Response
     */
    replaceOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(id: number, body: EmissionReductioDraftDataEntity): Observable<EmissionReductioDraftDataEntity> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionReductioDraftDataEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionReductioDraftDataEntity>;
        }));
    }

    protected processReplaceOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<EmissionReductioDraftDataEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmissionReductioDraftDataEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single EmissionReductioDraftDataEntity
     * @return Delete one base response
     */
    deleteOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(id: number): Observable<void> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple EmissionReductioDraftDataEntities
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyEmissionReductioDraftDataEntityResponseDto> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyEmissionReductioDraftDataEntityResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyEmissionReductioDraftDataEntityResponseDto>;
        }));
    }

    protected processGetManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<GetManyEmissionReductioDraftDataEntityResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyEmissionReductioDraftDataEntityResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single EmissionReductioDraftDataEntity
     * @return Get create one base response
     */
    createOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(body: EmissionReductioDraftDataEntity): Observable<EmissionReductioDraftDataEntity> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionReductioDraftDataEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionReductioDraftDataEntity>;
        }));
    }

    protected processCreateOneBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<EmissionReductioDraftDataEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EmissionReductioDraftDataEntity.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple EmissionReductioDraftDataEntities
     * @return Get create many base response
     */
    createManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(body: BulkDto): Observable<EmissionReductioDraftDataEntity[]> {
        let url_ = this.baseUrl + "/emission-reduction-draftdata/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmissionReductioDraftDataEntity[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmissionReductioDraftDataEntity[]>;
        }));
    }

    protected processCreateManyBaseEmissionReductionDraftdataControllerEmissionReductioDraftDataEntity(response: HttpResponseBase): Observable<EmissionReductioDraftDataEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(EmissionReductioDraftDataEntity.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Report
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseReportControllerReport(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processGetOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Report
     * @return Response
     */
    updateOneBaseReportControllerReport(id: number, body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processUpdateOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Report
     * @return Response
     */
    replaceOneBaseReportControllerReport(id: number, body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processReplaceOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Report.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Report
     * @return Delete one base response
     */
    deleteOneBaseReportControllerReport(id: number): Observable<void> {
        let url_ = this.baseUrl + "/report/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseReportControllerReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Reports
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseReportControllerReport(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyReportResponseDto> {
        let url_ = this.baseUrl + "/report?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyReportResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyReportResponseDto>;
        }));
    }

    protected processGetManyBaseReportControllerReport(response: HttpResponseBase): Observable<GetManyReportResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyReportResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Report
     * @return Get create one base response
     */
    createOneBaseReportControllerReport(body: Report): Observable<Report> {
        let url_ = this.baseUrl + "/report";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report>;
        }));
    }

    protected processCreateOneBaseReportControllerReport(response: HttpResponseBase): Observable<Report> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Report.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Reports
     * @return Get create many base response
     */
    createManyBaseReportControllerReport(body: BulkDto): Observable<Report[]> {
        let url_ = this.baseUrl + "/report/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseReportControllerReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseReportControllerReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Report[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Report[]>;
        }));
    }

    protected processCreateManyBaseReportControllerReport(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Report.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ApplicabilityEntity
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseApplicabilityControllerApplicabilityEntity(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ApplicabilityEntity> {
        let url_ = this.baseUrl + "/applicability/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicabilityEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicabilityEntity>;
        }));
    }

    protected processGetOneBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<ApplicabilityEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicabilityEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ApplicabilityEntity
     * @return Response
     */
    updateOneBaseApplicabilityControllerApplicabilityEntity(id: number, body: ApplicabilityEntity): Observable<ApplicabilityEntity> {
        let url_ = this.baseUrl + "/applicability/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicabilityEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicabilityEntity>;
        }));
    }

    protected processUpdateOneBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<ApplicabilityEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicabilityEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ApplicabilityEntity
     * @return Response
     */
    replaceOneBaseApplicabilityControllerApplicabilityEntity(id: number, body: ApplicabilityEntity): Observable<ApplicabilityEntity> {
        let url_ = this.baseUrl + "/applicability/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicabilityEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicabilityEntity>;
        }));
    }

    protected processReplaceOneBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<ApplicabilityEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicabilityEntity.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ApplicabilityEntity
     * @return Delete one base response
     */
    deleteOneBaseApplicabilityControllerApplicabilityEntity(id: number): Observable<void> {
        let url_ = this.baseUrl + "/applicability/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ApplicabilityEntities
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseApplicabilityControllerApplicabilityEntity(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyApplicabilityEntityResponseDto> {
        let url_ = this.baseUrl + "/applicability?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyApplicabilityEntityResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyApplicabilityEntityResponseDto>;
        }));
    }

    protected processGetManyBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<GetManyApplicabilityEntityResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyApplicabilityEntityResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ApplicabilityEntity
     * @return Get create one base response
     */
    createOneBaseApplicabilityControllerApplicabilityEntity(body: ApplicabilityEntity): Observable<ApplicabilityEntity> {
        let url_ = this.baseUrl + "/applicability";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicabilityEntity>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicabilityEntity>;
        }));
    }

    protected processCreateOneBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<ApplicabilityEntity> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicabilityEntity.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ApplicabilityEntities
     * @return Get create many base response
     */
    createManyBaseApplicabilityControllerApplicabilityEntity(body: BulkDto): Observable<ApplicabilityEntity[]> {
        let url_ = this.baseUrl + "/applicability/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseApplicabilityControllerApplicabilityEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseApplicabilityControllerApplicabilityEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ApplicabilityEntity[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ApplicabilityEntity[]>;
        }));
    }

    protected processCreateManyBaseApplicabilityControllerApplicabilityEntity(response: HttpResponseBase): Observable<ApplicabilityEntity[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ApplicabilityEntity.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Audit
     * @return Get create one base response
     */
    createOneBaseAuditControllerAudit(body: Audit): Observable<Audit> {
        let url_ = this.baseUrl + "/audit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Audit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Audit>;
        }));
    }

    protected processCreateOneBaseAuditControllerAudit(response: HttpResponseBase): Observable<Audit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Audit.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Audits
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseAuditControllerAudit(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyAuditResponseDto> {
        let url_ = this.baseUrl + "/audit?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyAuditResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyAuditResponseDto>;
        }));
    }

    protected processGetManyBaseAuditControllerAudit(response: HttpResponseBase): Observable<GetManyAuditResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyAuditResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Audit
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseAuditControllerAudit(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Audit> {
        let url_ = this.baseUrl + "/audit/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Audit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Audit>;
        }));
    }

    protected processGetOneBaseAuditControllerAudit(response: HttpResponseBase): Observable<Audit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Audit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Audit
     * @return Response
     */
    updateOneBaseAuditControllerAudit(id: number, body: Audit): Observable<Audit> {
        let url_ = this.baseUrl + "/audit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Audit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Audit>;
        }));
    }

    protected processUpdateOneBaseAuditControllerAudit(response: HttpResponseBase): Observable<Audit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Audit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Audit
     * @return Response
     */
    replaceOneBaseAuditControllerAudit(id: number, body: Audit): Observable<Audit> {
        let url_ = this.baseUrl + "/audit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Audit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Audit>;
        }));
    }

    protected processReplaceOneBaseAuditControllerAudit(response: HttpResponseBase): Observable<Audit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Audit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Audit
     * @return Delete one base response
     */
    deleteOneBaseAuditControllerAudit(id: number): Observable<void> {
        let url_ = this.baseUrl + "/audit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseAuditControllerAudit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Audits
     * @return Get create many base response
     */
    createManyBaseAuditControllerAudit(body: BulkDto): Observable<Audit[]> {
        let url_ = this.baseUrl + "/audit/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseAuditControllerAudit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseAuditControllerAudit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Audit[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Audit[]>;
        }));
    }

    protected processCreateManyBaseAuditControllerAudit(response: HttpResponseBase): Observable<Audit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Audit.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Project
     */
    createOneBaseProjectControllerProject(body: Project): Observable<Project> {
        let url_ = this.baseUrl + "/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processCreateOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Project.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Projects
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectControllerProject(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectResponseDto> {
        let url_ = this.baseUrl + "/project?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectResponseDto>;
        }));
    }

    protected processGetManyBaseProjectControllerProject(response: HttpResponseBase): Observable<GetManyProjectResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Project
     */
    updateOneBaseProjectControllerProject(id: number, body: Project): Observable<void> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateOneBaseProjectControllerProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Project
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectControllerProject(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Project> {
        let url_ = this.baseUrl + "/project/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processGetOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Project
     * @return Response
     */
    replaceOneBaseProjectControllerProject(id: number, body: Project): Observable<Project> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project>;
        }));
    }

    protected processReplaceOneBaseProjectControllerProject(response: HttpResponseBase): Observable<Project> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Project
     * @return Delete one base response
     */
    deleteOneBaseProjectControllerProject(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectControllerProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Projects
     * @return Get create many base response
     */
    createManyBaseProjectControllerProject(body: BulkDto): Observable<Project[]> {
        let url_ = this.baseUrl + "/project/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectControllerProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectControllerProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Project[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Project[]>;
        }));
    }

    protected processCreateManyBaseProjectControllerProject(response: HttpResponseBase): Observable<Project[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Project.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Country
     */
    updateOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processUpdateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Country
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCountryControllerCountry(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processGetOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Country
     * @return Response
     */
    replaceOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processReplaceOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Country
     * @return Delete one base response
     */
    deleteOneBaseCountryControllerCountry(id: number): Observable<void> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Country
     */
    createOneBaseCountryControllerCountry(body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country>;
        }));
    }

    protected processCreateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Country.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Countries
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCountryControllerCountry(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyCountryResponseDto> {
        let url_ = this.baseUrl + "/country?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyCountryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyCountryResponseDto>;
        }));
    }

    protected processGetManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<GetManyCountryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyCountryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Countries
     * @return Get create many base response
     */
    createManyBaseCountryControllerCountry(body: BulkDto): Observable<Country[]> {
        let url_ = this.baseUrl + "/country/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCountryControllerCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Country[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Country[]>;
        }));
    }

    protected processCreateManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Country.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Ndcs
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBaseNdcControllerNdc(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/ndc?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetManyBaseNdcControllerNdc(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Ndc
     * @return Get create one base response
     */
    createOneBaseNdcControllerNdc(body: Ndc): Observable<Ndc> {
        let url_ = this.baseUrl + "/ndc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Ndc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Ndc>;
        }));
    }

    protected processCreateOneBaseNdcControllerNdc(response: HttpResponseBase): Observable<Ndc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Ndc.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Ndc
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNdcControllerNdc(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Ndc> {
        let url_ = this.baseUrl + "/ndc/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Ndc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Ndc>;
        }));
    }

    protected processGetOneBaseNdcControllerNdc(response: HttpResponseBase): Observable<Ndc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Ndc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Ndc
     * @return Response
     */
    updateOneBaseNdcControllerNdc(id: number, body: Ndc): Observable<Ndc> {
        let url_ = this.baseUrl + "/ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Ndc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Ndc>;
        }));
    }

    protected processUpdateOneBaseNdcControllerNdc(response: HttpResponseBase): Observable<Ndc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Ndc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Ndc
     * @return Response
     */
    replaceOneBaseNdcControllerNdc(id: number, body: Ndc): Observable<Ndc> {
        let url_ = this.baseUrl + "/ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Ndc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Ndc>;
        }));
    }

    protected processReplaceOneBaseNdcControllerNdc(response: HttpResponseBase): Observable<Ndc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Ndc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Ndc
     * @return Delete one base response
     */
    deleteOneBaseNdcControllerNdc(id: number): Observable<void> {
        let url_ = this.baseUrl + "/ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNdcControllerNdc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Ndcs
     * @return Get create many base response
     */
    createManyBaseNdcControllerNdc(body: BulkDto): Observable<Ndc[]> {
        let url_ = this.baseUrl + "/ndc/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNdcControllerNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNdcControllerNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Ndc[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Ndc[]>;
        }));
    }

    protected processCreateManyBaseNdcControllerNdc(response: HttpResponseBase): Observable<Ndc[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Ndc.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single NdcSet
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseNdcSetControllerNdcSet(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<NdcSet> {
        let url_ = this.baseUrl + "/ndc-set/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NdcSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NdcSet>;
        }));
    }

    protected processGetOneBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<NdcSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NdcSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single NdcSet
     * @return Response
     */
    updateOneBaseNdcSetControllerNdcSet(id: number, body: NdcSet): Observable<NdcSet> {
        let url_ = this.baseUrl + "/ndc-set/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NdcSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NdcSet>;
        }));
    }

    protected processUpdateOneBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<NdcSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NdcSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single NdcSet
     * @return Response
     */
    replaceOneBaseNdcSetControllerNdcSet(id: number, body: NdcSet): Observable<NdcSet> {
        let url_ = this.baseUrl + "/ndc-set/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NdcSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NdcSet>;
        }));
    }

    protected processReplaceOneBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<NdcSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NdcSet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single NdcSet
     * @return Delete one base response
     */
    deleteOneBaseNdcSetControllerNdcSet(id: number): Observable<void> {
        let url_ = this.baseUrl + "/ndc-set/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple NdcSets
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseNdcSetControllerNdcSet(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyNdcSetResponseDto> {
        let url_ = this.baseUrl + "/ndc-set?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyNdcSetResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyNdcSetResponseDto>;
        }));
    }

    protected processGetManyBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<GetManyNdcSetResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyNdcSetResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single NdcSet
     * @return Get create one base response
     */
    createOneBaseNdcSetControllerNdcSet(body: NdcSet): Observable<NdcSet> {
        let url_ = this.baseUrl + "/ndc-set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NdcSet>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NdcSet>;
        }));
    }

    protected processCreateOneBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<NdcSet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NdcSet.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple NdcSets
     * @return Get create many base response
     */
    createManyBaseNdcSetControllerNdcSet(body: BulkDto): Observable<NdcSet[]> {
        let url_ = this.baseUrl + "/ndc-set/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseNdcSetControllerNdcSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseNdcSetControllerNdcSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NdcSet[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NdcSet[]>;
        }));
    }

    protected processCreateManyBaseNdcSetControllerNdcSet(response: HttpResponseBase): Observable<NdcSet[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(NdcSet.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single SubNdc
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSubNdcControllerSubNdc(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<SubNdc> {
        let url_ = this.baseUrl + "/sub-ndc/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubNdc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubNdc>;
        }));
    }

    protected processGetOneBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<SubNdc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubNdc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single SubNdc
     * @return Response
     */
    updateOneBaseSubNdcControllerSubNdc(id: number, body: SubNdc): Observable<SubNdc> {
        let url_ = this.baseUrl + "/sub-ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubNdc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubNdc>;
        }));
    }

    protected processUpdateOneBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<SubNdc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubNdc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single SubNdc
     * @return Response
     */
    replaceOneBaseSubNdcControllerSubNdc(id: number, body: SubNdc): Observable<SubNdc> {
        let url_ = this.baseUrl + "/sub-ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubNdc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubNdc>;
        }));
    }

    protected processReplaceOneBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<SubNdc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubNdc.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single SubNdc
     * @return Delete one base response
     */
    deleteOneBaseSubNdcControllerSubNdc(id: number): Observable<void> {
        let url_ = this.baseUrl + "/sub-ndc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple SubNdcs
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSubNdcControllerSubNdc(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySubNdcResponseDto> {
        let url_ = this.baseUrl + "/sub-ndc?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManySubNdcResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManySubNdcResponseDto>;
        }));
    }

    protected processGetManyBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<GetManySubNdcResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySubNdcResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single SubNdc
     * @return Get create one base response
     */
    createOneBaseSubNdcControllerSubNdc(body: SubNdc): Observable<SubNdc> {
        let url_ = this.baseUrl + "/sub-ndc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubNdc>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubNdc>;
        }));
    }

    protected processCreateOneBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<SubNdc> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubNdc.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple SubNdcs
     * @return Get create many base response
     */
    createManyBaseSubNdcControllerSubNdc(body: BulkDto): Observable<SubNdc[]> {
        let url_ = this.baseUrl + "/sub-ndc/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSubNdcControllerSubNdc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSubNdcControllerSubNdc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubNdc[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubNdc[]>;
        }));
    }

    protected processCreateManyBaseSubNdcControllerSubNdc(response: HttpResponseBase): Observable<SubNdc[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(SubNdc.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single MitigationActionType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMitigationActionControllerMitigationActionType(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<MitigationActionType> {
        let url_ = this.baseUrl + "/mitigation-action/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MitigationActionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MitigationActionType>;
        }));
    }

    protected processGetOneBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<MitigationActionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MitigationActionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single MitigationActionType
     * @return Response
     */
    updateOneBaseMitigationActionControllerMitigationActionType(id: number, body: MitigationActionType): Observable<MitigationActionType> {
        let url_ = this.baseUrl + "/mitigation-action/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MitigationActionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MitigationActionType>;
        }));
    }

    protected processUpdateOneBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<MitigationActionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MitigationActionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single MitigationActionType
     * @return Response
     */
    replaceOneBaseMitigationActionControllerMitigationActionType(id: number, body: MitigationActionType): Observable<MitigationActionType> {
        let url_ = this.baseUrl + "/mitigation-action/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MitigationActionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MitigationActionType>;
        }));
    }

    protected processReplaceOneBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<MitigationActionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MitigationActionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single MitigationActionType
     * @return Delete one base response
     */
    deleteOneBaseMitigationActionControllerMitigationActionType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/mitigation-action/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple MitigationActionTypes
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMitigationActionControllerMitigationActionType(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMitigationActionTypeResponseDto> {
        let url_ = this.baseUrl + "/mitigation-action?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyMitigationActionTypeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyMitigationActionTypeResponseDto>;
        }));
    }

    protected processGetManyBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<GetManyMitigationActionTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMitigationActionTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single MitigationActionType
     * @return Get create one base response
     */
    createOneBaseMitigationActionControllerMitigationActionType(body: MitigationActionType): Observable<MitigationActionType> {
        let url_ = this.baseUrl + "/mitigation-action";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MitigationActionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MitigationActionType>;
        }));
    }

    protected processCreateOneBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<MitigationActionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = MitigationActionType.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple MitigationActionTypes
     * @return Get create many base response
     */
    createManyBaseMitigationActionControllerMitigationActionType(body: BulkDto): Observable<MitigationActionType[]> {
        let url_ = this.baseUrl + "/mitigation-action/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMitigationActionControllerMitigationActionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMitigationActionControllerMitigationActionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MitigationActionType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MitigationActionType[]>;
        }));
    }

    protected processCreateManyBaseMitigationActionControllerMitigationActionType(response: HttpResponseBase): Observable<MitigationActionType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(MitigationActionType.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectOwner
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectOwnerControllerProjectOwner(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectOwner> {
        let url_ = this.baseUrl + "/project-owner/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectOwner>;
        }));
    }

    protected processGetOneBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<ProjectOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectOwner.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectOwner
     * @return Response
     */
    updateOneBaseProjectOwnerControllerProjectOwner(id: number, body: ProjectOwner): Observable<ProjectOwner> {
        let url_ = this.baseUrl + "/project-owner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectOwner>;
        }));
    }

    protected processUpdateOneBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<ProjectOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectOwner.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectOwner
     * @return Response
     */
    replaceOneBaseProjectOwnerControllerProjectOwner(id: number, body: ProjectOwner): Observable<ProjectOwner> {
        let url_ = this.baseUrl + "/project-owner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectOwner>;
        }));
    }

    protected processReplaceOneBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<ProjectOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectOwner.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectOwner
     * @return Delete one base response
     */
    deleteOneBaseProjectOwnerControllerProjectOwner(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-owner/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectOwners
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectOwnerControllerProjectOwner(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectOwnerResponseDto> {
        let url_ = this.baseUrl + "/project-owner?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectOwnerResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectOwnerResponseDto>;
        }));
    }

    protected processGetManyBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<GetManyProjectOwnerResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectOwnerResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectOwner
     * @return Get create one base response
     */
    createOneBaseProjectOwnerControllerProjectOwner(body: ProjectOwner): Observable<ProjectOwner> {
        let url_ = this.baseUrl + "/project-owner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectOwner>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectOwner>;
        }));
    }

    protected processCreateOneBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<ProjectOwner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectOwner.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectOwners
     * @return Get create many base response
     */
    createManyBaseProjectOwnerControllerProjectOwner(body: BulkDto): Observable<ProjectOwner[]> {
        let url_ = this.baseUrl + "/project-owner/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectOwnerControllerProjectOwner(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectOwnerControllerProjectOwner(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectOwner[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectOwner[]>;
        }));
    }

    protected processCreateManyBaseProjectOwnerControllerProjectOwner(response: HttpResponseBase): Observable<ProjectOwner[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectOwner.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Sectors
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBaseSectorControllerSector(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/sector?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetManyBaseSectorControllerSector(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Sector
     */
    createOneBaseSectorControllerSector(body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sector>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sector>;
        }));
    }

    protected processCreateOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Sector.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Sector
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSectorControllerSector(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sector>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sector>;
        }));
    }

    protected processGetOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Sector
     * @return Response
     */
    updateOneBaseSectorControllerSector(id: number, body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sector>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sector>;
        }));
    }

    protected processUpdateOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Sector
     * @return Response
     */
    replaceOneBaseSectorControllerSector(id: number, body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sector>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sector>;
        }));
    }

    protected processReplaceOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Sector
     * @return Delete one base response
     */
    deleteOneBaseSectorControllerSector(id: number): Observable<void> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseSectorControllerSector(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Sectors
     * @return Get create many base response
     */
    createManyBaseSectorControllerSector(body: BulkDto): Observable<Sector[]> {
        let url_ = this.baseUrl + "/sector/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSectorControllerSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Sector[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Sector[]>;
        }));
    }

    protected processCreateManyBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Sector.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectStatus
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectStatusControllerProjectStatus(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectStatus>;
        }));
    }

    protected processGetOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectStatus
     * @return Response
     */
    updateOneBaseProjectStatusControllerProjectStatus(id: number, body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectStatus>;
        }));
    }

    protected processUpdateOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectStatus
     * @return Response
     */
    replaceOneBaseProjectStatusControllerProjectStatus(id: number, body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectStatus>;
        }));
    }

    protected processReplaceOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectStatus
     * @return Delete one base response
     */
    deleteOneBaseProjectStatusControllerProjectStatus(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectStatuses
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectStatusControllerProjectStatus(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectStatusResponseDto> {
        let url_ = this.baseUrl + "/project-status?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectStatusResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectStatusResponseDto>;
        }));
    }

    protected processGetManyBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<GetManyProjectStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectStatus
     * @return Get create one base response
     */
    createOneBaseProjectStatusControllerProjectStatus(body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectStatus>;
        }));
    }

    protected processCreateOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectStatus.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectStatuses
     * @return Get create many base response
     */
    createManyBaseProjectStatusControllerProjectStatus(body: BulkDto): Observable<ProjectStatus[]> {
        let url_ = this.baseUrl + "/project-status/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectStatusControllerProjectStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectStatus[]>;
        }));
    }

    protected processCreateManyBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectStatus.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDocumentControllerDocuments(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processGetOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Documents
     * @return Response
     */
    updateOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processUpdateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Documents
     * @return Response
     */
    replaceOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processReplaceOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Documents
     * @return Delete one base response
     */
    deleteOneBaseDocumentControllerDocuments(id: number): Observable<void> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDocumentControllerDocuments(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDocumentsResponseDto> {
        let url_ = this.baseUrl + "/document?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyDocumentsResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyDocumentsResponseDto>;
        }));
    }

    protected processGetManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<GetManyDocumentsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDocumentsResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Documents
     * @return Get create one base response
     */
    createOneBaseDocumentControllerDocuments(body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents>;
        }));
    }

    protected processCreateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Documents.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Documents
     * @return Get create many base response
     */
    createManyBaseDocumentControllerDocuments(body: BulkDto): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDocumentControllerDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents[]>;
        }));
    }

    protected processCreateManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Documents.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single User
     * @return Get create one base response
     */
    createOneBaseUsersControllerUser(body: User): Observable<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processCreateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Users
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBaseUsersControllerUser(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/users?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetManyBaseUsersControllerUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single User
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUsersControllerUser(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single User
     * @return Delete one base response
     */
    deleteOneBaseUsersControllerUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUsersControllerUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single User
     * @return Response
     */
    updateOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUpdateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single User
     * @return Response
     */
    replaceOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processReplaceOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Users
     * @return Get create many base response
     */
    createManyBaseUsersControllerUser(body: BulkDto): Observable<User[]> {
        let url_ = this.baseUrl + "/users/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUsersControllerUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processCreateManyBaseUsersControllerUser(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(User.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single Institution
     */
    createOneBaseInstitutionControllerInstitution(body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution>;
        }));
    }

    protected processCreateOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Institution.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple Institutions
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseInstitutionControllerInstitution(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyInstitutionResponseDto> {
        let url_ = this.baseUrl + "/institution?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyInstitutionResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyInstitutionResponseDto>;
        }));
    }

    protected processGetManyBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<GetManyInstitutionResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyInstitutionResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single Institution
     */
    updateOneBaseInstitutionControllerInstitution(id: number, body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution>;
        }));
    }

    protected processUpdateOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single Institution
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseInstitutionControllerInstitution(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution>;
        }));
    }

    protected processGetOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single Institution
     * @return Response
     */
    replaceOneBaseInstitutionControllerInstitution(id: number, body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution>;
        }));
    }

    protected processReplaceOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single Institution
     * @return Delete one base response
     */
    deleteOneBaseInstitutionControllerInstitution(id: number): Observable<void> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple Institutions
     * @return Get create many base response
     */
    createManyBaseInstitutionControllerInstitution(body: BulkDto): Observable<Institution[]> {
        let url_ = this.baseUrl + "/institution/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseInstitutionControllerInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution[]>;
        }));
    }

    protected processCreateManyBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Institution.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single InstitutionType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseInstitutionTypeControllerInstitutionType(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<InstitutionType> {
        let url_ = this.baseUrl + "/institution-type/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionType>;
        }));
    }

    protected processGetOneBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<InstitutionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single InstitutionType
     * @return Response
     */
    updateOneBaseInstitutionTypeControllerInstitutionType(id: number, body: InstitutionType): Observable<InstitutionType> {
        let url_ = this.baseUrl + "/institution-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionType>;
        }));
    }

    protected processUpdateOneBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<InstitutionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single InstitutionType
     * @return Response
     */
    replaceOneBaseInstitutionTypeControllerInstitutionType(id: number, body: InstitutionType): Observable<InstitutionType> {
        let url_ = this.baseUrl + "/institution-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionType>;
        }));
    }

    protected processReplaceOneBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<InstitutionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single InstitutionType
     * @return Delete one base response
     */
    deleteOneBaseInstitutionTypeControllerInstitutionType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/institution-type/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple InstitutionTypes
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseInstitutionTypeControllerInstitutionType(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyInstitutionTypeResponseDto> {
        let url_ = this.baseUrl + "/institution-type?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyInstitutionTypeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyInstitutionTypeResponseDto>;
        }));
    }

    protected processGetManyBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<GetManyInstitutionTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyInstitutionTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single InstitutionType
     * @return Get create one base response
     */
    createOneBaseInstitutionTypeControllerInstitutionType(body: InstitutionType): Observable<InstitutionType> {
        let url_ = this.baseUrl + "/institution-type";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionType>;
        }));
    }

    protected processCreateOneBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<InstitutionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InstitutionType.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple InstitutionTypes
     * @return Get create many base response
     */
    createManyBaseInstitutionTypeControllerInstitutionType(body: BulkDto): Observable<InstitutionType[]> {
        let url_ = this.baseUrl + "/institution-type/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseInstitutionTypeControllerInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseInstitutionTypeControllerInstitutionType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionType[]>;
        }));
    }

    protected processCreateManyBaseInstitutionTypeControllerInstitutionType(response: HttpResponseBase): Observable<InstitutionType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(InstitutionType.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single InstitutionCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseInstitutionCategoryControllerInstitutionCategory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<InstitutionCategory> {
        let url_ = this.baseUrl + "/institution-category/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionCategory>;
        }));
    }

    protected processGetOneBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single InstitutionCategory
     * @return Response
     */
    updateOneBaseInstitutionCategoryControllerInstitutionCategory(id: number, body: InstitutionCategory): Observable<InstitutionCategory> {
        let url_ = this.baseUrl + "/institution-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionCategory>;
        }));
    }

    protected processUpdateOneBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single InstitutionCategory
     * @return Response
     */
    replaceOneBaseInstitutionCategoryControllerInstitutionCategory(id: number, body: InstitutionCategory): Observable<InstitutionCategory> {
        let url_ = this.baseUrl + "/institution-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionCategory>;
        }));
    }

    protected processReplaceOneBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstitutionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single InstitutionCategory
     * @return Delete one base response
     */
    deleteOneBaseInstitutionCategoryControllerInstitutionCategory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/institution-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple InstitutionCategories
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseInstitutionCategoryControllerInstitutionCategory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyInstitutionCategoryResponseDto> {
        let url_ = this.baseUrl + "/institution-category?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyInstitutionCategoryResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyInstitutionCategoryResponseDto>;
        }));
    }

    protected processGetManyBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<GetManyInstitutionCategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyInstitutionCategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single InstitutionCategory
     * @return Get create one base response
     */
    createOneBaseInstitutionCategoryControllerInstitutionCategory(body: InstitutionCategory): Observable<InstitutionCategory> {
        let url_ = this.baseUrl + "/institution-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionCategory>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionCategory>;
        }));
    }

    protected processCreateOneBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = InstitutionCategory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple InstitutionCategories
     * @return Get create many base response
     */
    createManyBaseInstitutionCategoryControllerInstitutionCategory(body: BulkDto): Observable<InstitutionCategory[]> {
        let url_ = this.baseUrl + "/institution-category/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseInstitutionCategoryControllerInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseInstitutionCategoryControllerInstitutionCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InstitutionCategory[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InstitutionCategory[]>;
        }));
    }

    protected processCreateManyBaseInstitutionCategoryControllerInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(InstitutionCategory.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single ProjectApprovalStatus
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectApprovalStatusControllerProjectApprovalStatus(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectApprovalStatus> {
        let url_ = this.baseUrl + "/project-approval-status/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectApprovalStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectApprovalStatus>;
        }));
    }

    protected processGetOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<ProjectApprovalStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectApprovalStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single ProjectApprovalStatus
     * @return Response
     */
    updateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(id: number, body: ProjectApprovalStatus): Observable<ProjectApprovalStatus> {
        let url_ = this.baseUrl + "/project-approval-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectApprovalStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectApprovalStatus>;
        }));
    }

    protected processUpdateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<ProjectApprovalStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectApprovalStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single ProjectApprovalStatus
     * @return Response
     */
    replaceOneBaseProjectApprovalStatusControllerProjectApprovalStatus(id: number, body: ProjectApprovalStatus): Observable<ProjectApprovalStatus> {
        let url_ = this.baseUrl + "/project-approval-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectApprovalStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectApprovalStatus>;
        }));
    }

    protected processReplaceOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<ProjectApprovalStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectApprovalStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single ProjectApprovalStatus
     * @return Delete one base response
     */
    deleteOneBaseProjectApprovalStatusControllerProjectApprovalStatus(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-approval-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple ProjectApprovalStatuses
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectApprovalStatusControllerProjectApprovalStatus(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectApprovalStatusResponseDto> {
        let url_ = this.baseUrl + "/project-approval-status?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyProjectApprovalStatusResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyProjectApprovalStatusResponseDto>;
        }));
    }

    protected processGetManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<GetManyProjectApprovalStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectApprovalStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single ProjectApprovalStatus
     * @return Get create one base response
     */
    createOneBaseProjectApprovalStatusControllerProjectApprovalStatus(body: ProjectApprovalStatus): Observable<ProjectApprovalStatus> {
        let url_ = this.baseUrl + "/project-approval-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectApprovalStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectApprovalStatus>;
        }));
    }

    protected processCreateOneBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<ProjectApprovalStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectApprovalStatus.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple ProjectApprovalStatuses
     * @return Get create many base response
     */
    createManyBaseProjectApprovalStatusControllerProjectApprovalStatus(body: BulkDto): Observable<ProjectApprovalStatus[]> {
        let url_ = this.baseUrl + "/project-approval-status/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProjectApprovalStatus[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProjectApprovalStatus[]>;
        }));
    }

    protected processCreateManyBaseProjectApprovalStatusControllerProjectApprovalStatus(response: HttpResponseBase): Observable<ProjectApprovalStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectApprovalStatus.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single UserType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUserTypeControllerUserType(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType>;
        }));
    }

    protected processGetOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single UserType
     * @return Response
     */
    updateOneBaseUserTypeControllerUserType(id: number, body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType>;
        }));
    }

    protected processUpdateOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single UserType
     * @return Response
     */
    replaceOneBaseUserTypeControllerUserType(id: number, body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType>;
        }));
    }

    protected processReplaceOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single UserType
     * @return Delete one base response
     */
    deleteOneBaseUserTypeControllerUserType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple UserTypes
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUserTypeControllerUserType(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUserTypeResponseDto> {
        let url_ = this.baseUrl + "/usertype?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyUserTypeResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyUserTypeResponseDto>;
        }));
    }

    protected processGetManyBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<GetManyUserTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUserTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single UserType
     * @return Get create one base response
     */
    createOneBaseUserTypeControllerUserType(body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType>;
        }));
    }

    protected processCreateOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserType.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple UserTypes
     * @return Get create many base response
     */
    createManyBaseUserTypeControllerUserType(body: BulkDto): Observable<UserType[]> {
        let url_ = this.baseUrl + "/usertype/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUserTypeControllerUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserType[]>;
        }));
    }

    protected processCreateManyBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UserType.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Delete a single LearningMaterial
     */
    deleteOneBaseLearningMaterialControllerLearningMaterial(id: number): Observable<number> {
        let url_ = this.baseUrl + "/learning-material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processDeleteOneBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve a single LearningMaterial
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseLearningMaterialControllerLearningMaterial(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<LearningMaterial> {
        let url_ = this.baseUrl + "/learning-material/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterial>;
        }));
    }

    protected processGetOneBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<LearningMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LearningMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Update a single LearningMaterial
     * @return Response
     */
    updateOneBaseLearningMaterialControllerLearningMaterial(id: number, body: LearningMaterial): Observable<LearningMaterial> {
        let url_ = this.baseUrl + "/learning-material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterial>;
        }));
    }

    protected processUpdateOneBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<LearningMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LearningMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Replace a single LearningMaterial
     * @return Response
     */
    replaceOneBaseLearningMaterialControllerLearningMaterial(id: number, body: LearningMaterial): Observable<LearningMaterial> {
        let url_ = this.baseUrl + "/learning-material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterial>;
        }));
    }

    protected processReplaceOneBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<LearningMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LearningMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create a single LearningMaterial
     */
    createOneBaseLearningMaterialControllerLearningMaterial(body: LearningMaterial): Observable<LearningMaterial> {
        let url_ = this.baseUrl + "/learning-material";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterial>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterial>;
        }));
    }

    protected processCreateOneBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<LearningMaterial> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LearningMaterial.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = LearningMaterial.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Retrieve multiple LearningMaterials
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseLearningMaterialControllerLearningMaterial(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyLearningMaterialResponseDto> {
        let url_ = this.baseUrl + "/learning-material?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetManyLearningMaterialResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetManyLearningMaterialResponseDto>;
        }));
    }

    protected processGetManyBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<GetManyLearningMaterialResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyLearningMaterialResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create multiple LearningMaterials
     * @return Get create many base response
     */
    createManyBaseLearningMaterialControllerLearningMaterial(body: BulkDto): Observable<LearningMaterial[]> {
        let url_ = this.baseUrl + "/learning-material/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseLearningMaterialControllerLearningMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseLearningMaterialControllerLearningMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterial[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterial[]>;
        }));
    }

    protected processCreateManyBaseLearningMaterialControllerLearningMaterial(response: HttpResponseBase): Observable<LearningMaterial[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(LearningMaterial.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MethodologyControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getMethoDetails(page: number, limit: number, filterText: string, indicatorId: number, developedBy: string): Observable<any> {
        let url_ = this.baseUrl + "/methodology/methodology/methodologyinfo/{page}/{limit}/{indicatorId}/{filterText}/{developedBy}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (indicatorId === undefined || indicatorId === null)
            throw new Error("The parameter 'indicatorId' must be defined and cannot be null.");
        else
            url_ += "indicatorId=" + encodeURIComponent("" + indicatorId) + "&";
        if (developedBy === undefined || developedBy === null)
            throw new Error("The parameter 'developedBy' must be defined and cannot be null.");
        else
            url_ += "developedBy=" + encodeURIComponent("" + developedBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMethoDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMethoDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetMethoDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAuditDetails(page: number, limit: number, userTypeId: string, action: string, editedOn: string, filterText: string, institutionId: number): Observable<any> {
        let url_ = this.baseUrl + "/audit/audit/auditinfo/{page}/{limit}/{userTypeId}/{action}/{editedOn}/{filterText}/{institutionId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (userTypeId === undefined || userTypeId === null)
            throw new Error("The parameter 'userTypeId' must be defined and cannot be null.");
        else
            url_ += "userTypeId=" + encodeURIComponent("" + userTypeId) + "&";
        if (action === undefined || action === null)
            throw new Error("The parameter 'action' must be defined and cannot be null.");
        else
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (editedOn === undefined || editedOn === null)
            throw new Error("The parameter 'editedOn' must be defined and cannot be null.");
        else
            url_ += "editedOn=" + encodeURIComponent("" + editedOn) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAuditDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProjectControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllClimateActionList(page: number, limit: number, filterText: string, projectStatusId: number, projectApprovalStatusId: number, countryId: number, sectorId: number): Observable<any> {
        let url_ = this.baseUrl + "/project/AllClimateAction/projectinfo/{page}/{limit}/{filterText}/{projectStatusId}/{projectApprovalStatusId}/{countryId}/{sectorId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (projectStatusId === undefined || projectStatusId === null)
            throw new Error("The parameter 'projectStatusId' must be defined and cannot be null.");
        else
            url_ += "projectStatusId=" + encodeURIComponent("" + projectStatusId) + "&";
        if (projectApprovalStatusId === undefined || projectApprovalStatusId === null)
            throw new Error("The parameter 'projectApprovalStatusId' must be defined and cannot be null.");
        else
            url_ += "projectApprovalStatusId=" + encodeURIComponent("" + projectApprovalStatusId) + "&";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClimateActionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClimateActionList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllClimateActionList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getClimateActionDetails(page: number, limit: number, sectorId: number, statusId: number, mitigationActionTypeId: number, editedOn: string, filterText: string): Observable<any> {
        let url_ = this.baseUrl + "/project/project/projectinfo/{page}/{limit}/{sectorId}/{statusId}/{mitigationActionTypeId}/{editedOn}/{filterText}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        if (mitigationActionTypeId === undefined || mitigationActionTypeId === null)
            throw new Error("The parameter 'mitigationActionTypeId' must be defined and cannot be null.");
        else
            url_ += "mitigationActionTypeId=" + encodeURIComponent("" + mitigationActionTypeId) + "&";
        if (editedOn === undefined || editedOn === null)
            throw new Error("The parameter 'editedOn' must be defined and cannot be null.");
        else
            url_ += "editedOn=" + encodeURIComponent("" + editedOn) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClimateActionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClimateActionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetClimateActionDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllClimateActionDetails(page: number, limit: number, filterText: string, projectStatusId: number, projectApprovalStatusId: number, assessmentStatusName: string, active: number, countryId: number, sectorId: number): Observable<any> {
        let url_ = this.baseUrl + "/project/AllClimateActions/projectinfo/{page}/{limit}/{filterText}/{projectStatusId}/{projectApprovalStatusId}/{assessmentStatusName}/{Active}/{countryId}/{sectorId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (projectStatusId === undefined || projectStatusId === null)
            throw new Error("The parameter 'projectStatusId' must be defined and cannot be null.");
        else
            url_ += "projectStatusId=" + encodeURIComponent("" + projectStatusId) + "&";
        if (projectApprovalStatusId === undefined || projectApprovalStatusId === null)
            throw new Error("The parameter 'projectApprovalStatusId' must be defined and cannot be null.");
        else
            url_ += "projectApprovalStatusId=" + encodeURIComponent("" + projectApprovalStatusId) + "&";
        if (assessmentStatusName === undefined || assessmentStatusName === null)
            throw new Error("The parameter 'assessmentStatusName' must be defined and cannot be null.");
        else
            url_ += "assessmentStatusName=" + encodeURIComponent("" + assessmentStatusName) + "&";
        if (active === undefined || active === null)
            throw new Error("The parameter 'active' must be defined and cannot be null.");
        else
            url_ += "Active=" + encodeURIComponent("" + active) + "&";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClimateActionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClimateActionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllClimateActionDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CountryControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCountry(countryId: number): Observable<any> {
        let url_ = this.baseUrl + "/country/country1?";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetCountry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveCountry(): Observable<any> {
        let url_ = this.baseUrl + "/country/getActiveCountry";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetActiveCountry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCountrySector(): Observable<any> {
        let url_ = this.baseUrl + "/country/country-sector";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountrySector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountrySector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetCountrySector(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCo(): Observable<any> {
        let url_ = this.baseUrl + "/country/all-co";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllCo(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountry(page: number, limit: number, insId: number): Observable<any> {
        let url_ = this.baseUrl + "/country/get-country/{page}/{limit}/{insId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (insId === undefined || insId === null)
            throw new Error("The parameter 'insId' must be defined and cannot be null.");
        else
            url_ += "insId=" + encodeURIComponent("" + insId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllCountry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCountryByFilter(page: number, limit: number, filter: string): Observable<any> {
        let url_ = this.baseUrl + "/country/get-bycountry/{page}/{limit}/{filter}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCountryByFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCountryByFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllCountryByFilter(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SectorControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSectorDetails(page: number, limit: number, filterText: string): Observable<any> {
        let url_ = this.baseUrl + "/sector/sector/sectorinfo/{page}/{limit}/{filterText}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSectorDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSectorDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetSectorDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSector(sectorId: number): Observable<any> {
        let url_ = this.baseUrl + "/sector/sector1?";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetSector(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DocumentControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    uploadFile(body: Documents): Observable<void> {
        let url_ = this.baseUrl + "/document/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadFile2(): Observable<void> {
        let url_ = this.baseUrl + "/document/upload2/{oid}/{owner}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadFile3(): Observable<void> {
        let url_ = this.baseUrl + "/document/upload3/{oid}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadFile3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDoc(docId: number): Observable<void> {
        let url_ = this.baseUrl + "/document/delete/{docId}";
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined.");
        url_ = url_.replace("{docId}", encodeURIComponent("" + docId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDocuments(oid: number, owner: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocument/{oid}/{owner}";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined.");
        url_ = url_.replace("{oid}", encodeURIComponent("" + oid));
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Documents[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Documents[]>;
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    downloadDocuments(did: number, state: string): Observable<void> {
        let url_ = this.baseUrl + "/document/downloadDocument/{state}/{did}";
        if (did === undefined || did === null)
            throw new Error("The parameter 'did' must be defined.");
        url_ = url_.replace("{did}", encodeURIComponent("" + did));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocuments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDownloadDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(body: AuthCredentialDto): Observable<any> {
        let url_ = this.baseUrl + "/auth/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    validateResetPassword(email: string, token: string): Observable<boolean> {
        let url_ = this.baseUrl + "/auth/auth/validate-reset-password/{email}/{token}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processValidateResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(body: ResetPassword): Observable<boolean> {
        let url_ = this.baseUrl + "/auth/auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(body: ForgotPasswordDto): Observable<any> {
        let url_ = this.baseUrl + "/auth/auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UsersControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    changeStatus(id: number, status: number): Observable<User> {
        let url_ = this.baseUrl + "/users/changeStatus?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findUserByUserType(): Observable<any> {
        let url_ = this.baseUrl + "/users/findUserBy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUserByUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUserByUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFindUserByUserType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUserAvailable(userName: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/isUserAvailable/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUserAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findUserByUserName(userName: string): Observable<any> {
        let url_ = this.baseUrl + "/users/findUserByUserName/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUserByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUserByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFindUserByUserName(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allUserDetails(page: number, limit: number, filterText: string, userTypeId: number): Observable<any> {
        let url_ = this.baseUrl + "/users/AllUserDetails/userDetalils/{page}/{limit}/{filterText}/{userTypeId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (userTypeId === undefined || userTypeId === null)
            throw new Error("The parameter 'userTypeId' must be defined and cannot be null.");
        else
            url_ += "userTypeId=" + encodeURIComponent("" + userTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllUserDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllUserDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processAllUserDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserType(type: string): Observable<any[]> {
        let url_ = this.baseUrl + "/users/user-type/{type}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined and cannot be null.");
        else
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any[]>;
        }));
    }

    protected processGetUserType(response: HttpResponseBase): Observable<any[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserByCountry(body: ReqUserDto): Observable<any> {
        let url_ = this.baseUrl + "/users/user-country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetUserByCountry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InstitutionControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getInstiDetails(page: number, limit: number, filterText: string, countryId: number): Observable<any> {
        let url_ = this.baseUrl + "/institution/institution/institutioninfo/{page}/{limit}/{filterText}/{countryId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstiDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstiDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetInstiDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getInstitutionDetails(countryId: number): Observable<any> {
        let url_ = this.baseUrl + "/institution/institution/institutiId?";
        if (countryId === undefined || countryId === null)
            throw new Error("The parameter 'countryId' must be defined and cannot be null.");
        else
            url_ += "countryId=" + encodeURIComponent("" + countryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstitutionDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutionDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetInstitutionDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPmuAdminAssignInstitution(): Observable<any> {
        let url_ = this.baseUrl + "/institution/institution/institutioninfopmu";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPmuAdminAssignInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPmuAdminAssignInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetPmuAdminAssignInstitution(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllIns(): Observable<Institution[]> {
        let url_ = this.baseUrl + "/institution/allIns";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIns(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIns(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Institution[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Institution[]>;
        }));
    }

    protected processGetAllIns(response: HttpResponseBase): Observable<Institution[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Institution.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivateInstitution(instiId: number): Observable<any> {
        let url_ = this.baseUrl + "/institution/deactivateInstituion?";
        if (instiId === undefined || instiId === null)
            throw new Error("The parameter 'instiId' must be defined and cannot be null.");
        else
            url_ += "instiId=" + encodeURIComponent("" + instiId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateInstitution(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processDeactivateInstitution(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InstitutionTypeControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    findInstitutionTypeByUserType(userId: number): Observable<any> {
        let url_ = this.baseUrl + "/institution-type/institutionTypeByUserType?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindInstitutionTypeByUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindInstitutionTypeByUserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processFindInstitutionTypeByUserType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCo(): Observable<any> {
        let url_ = this.baseUrl + "/institution-type/type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetAllCo(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class IndicatorControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(body: CreateIndicatorDto): Observable<string> {
        let url_ = this.baseUrl + "/indicator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findAll(): Observable<Indicator[]> {
        let url_ = this.baseUrl + "/indicator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Indicator[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Indicator[]>;
        }));
    }

    protected processFindAll(response: HttpResponseBase): Observable<Indicator[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Indicator.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, body: UpdateIndicatorDto): Observable<string> {
        let url_ = this.baseUrl + "/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    remove(id: string): Observable<string> {
        let url_ = this.baseUrl + "/indicator/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LearningMaterialControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getLearningMaterialDetails(page: number, limit: number, filterText: string, typeId: number, sectorId: number, sortOrder: number, sortType: number): Observable<any> {
        let url_ = this.baseUrl + "/learning-material/learning-material/learning-materialinfo/{page}/{limit}/{filterText}/{typeId}/{sectorId}/{sortOrder}/{sortType}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filterText === undefined || filterText === null)
            throw new Error("The parameter 'filterText' must be defined and cannot be null.");
        else
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&";
        if (typeId === undefined || typeId === null)
            throw new Error("The parameter 'typeId' must be defined and cannot be null.");
        else
            url_ += "typeId=" + encodeURIComponent("" + typeId) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (sortOrder === undefined || sortOrder === null)
            throw new Error("The parameter 'sortOrder' must be defined and cannot be null.");
        else
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (sortType === undefined || sortType === null)
            throw new Error("The parameter 'sortType' must be defined and cannot be null.");
        else
            url_ += "sortType=" + encodeURIComponent("" + sortType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLearningMaterialDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLearningMaterialDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<any>;
                }
            } else
                return _observableThrow(response_) as any as Observable<any>;
        }));
    }

    protected processGetLearningMaterialDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getalluserType(): Observable<LearningMaterialUserType[]> {
        let url_ = this.baseUrl + "/learning-material/user-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetalluserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetalluserType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterialUserType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterialUserType[]>;
        }));
    }

    protected processGetalluserType(response: HttpResponseBase): Observable<LearningMaterialUserType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LearningMaterialUserType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getallsector(): Observable<LearningMaterialSector[]> {
        let url_ = this.baseUrl + "/learning-material/sector";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetallsector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetallsector(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LearningMaterialSector[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LearningMaterialSector[]>;
        }));
    }

    protected processGetallsector(response: HttpResponseBase): Observable<LearningMaterialSector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(LearningMaterialSector.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetManyFinancingSchemeResponseDto implements IGetManyFinancingSchemeResponseDto {
    data: FinancingScheme[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyFinancingSchemeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(FinancingScheme.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyFinancingSchemeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyFinancingSchemeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyFinancingSchemeResponseDto {
        const json = this.toJSON();
        let result = new GetManyFinancingSchemeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyFinancingSchemeResponseDto {
    data: FinancingScheme[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class FinancingScheme implements IFinancingScheme {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IFinancingScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): FinancingScheme {
        data = typeof data === 'object' ? data : {};
        let result = new FinancingScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): FinancingScheme {
        const json = this.toJSON();
        let result = new FinancingScheme();
        result.init(json);
        return result;
    }
}

export interface IFinancingScheme {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class BulkDto implements IBulkDto {

    [key: string]: any;

    constructor(data?: IBulkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): BulkDto {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): BulkDto {
        const json = this.toJSON();
        let result = new BulkDto();
        result.init(json);
        return result;
    }
}

export interface IBulkDto {

    [key: string]: any;
}

export class GetManyMethodologyDataResponseDto implements IGetManyMethodologyDataResponseDto {
    data: MethodologyData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyMethodologyDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(MethodologyData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMethodologyDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMethodologyDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMethodologyDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyMethodologyDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMethodologyDataResponseDto {
    data: MethodologyData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManySectorResponseDto implements IGetManySectorResponseDto {
    data: Sector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManySectorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Sector.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySectorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySectorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManySectorResponseDto {
        const json = this.toJSON();
        let result = new GetManySectorResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySectorResponseDto {
    data: Sector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyCountryResponseDto implements IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyCountryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Country.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyCountryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyCountryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyCountryResponseDto {
        const json = this.toJSON();
        let result = new GetManyCountryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyInstitutionResponseDto implements IGetManyInstitutionResponseDto {
    data: Institution[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyInstitutionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Institution.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyInstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyInstitutionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyInstitutionResponseDto {
        const json = this.toJSON();
        let result = new GetManyInstitutionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyInstitutionResponseDto {
    data: Institution[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyInstitutionTypeResponseDto implements IGetManyInstitutionTypeResponseDto {
    data: InstitutionType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyInstitutionTypeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(InstitutionType.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyInstitutionTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyInstitutionTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyInstitutionTypeResponseDto {
        const json = this.toJSON();
        let result = new GetManyInstitutionTypeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyInstitutionTypeResponseDto {
    data: InstitutionType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class InstitutionType implements IInstitutionType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IInstitutionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): InstitutionType {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): InstitutionType {
        const json = this.toJSON();
        let result = new InstitutionType();
        result.init(json);
        return result;
    }
}

export interface IInstitutionType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class Institution implements IInstitution {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    uniqueIdentification: string;
    type: InstitutionType;
    isNational: boolean;
    parentInstitution: Institution;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    address: string;
    contactNumber: string;
    countries: Country[];

    [key: string]: any;

    constructor(data?: IInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = new InstitutionType();
            this.countries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.type = _data["type"] ? InstitutionType.fromJS(_data["type"]) : new InstitutionType();
            this.isNational = _data["isNational"];
            this.parentInstitution = _data["parentInstitution"] ? Institution.fromJS(_data["parentInstitution"]) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.address = _data["address"];
            this.contactNumber = _data["contactNumber"];
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["isNational"] = this.isNational;
        data["parentInstitution"] = this.parentInstitution ? this.parentInstitution.toJSON() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["address"] = this.address;
        data["contactNumber"] = this.contactNumber;
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item.toJSON());
        }
        return data;
    }

    clone(): Institution {
        const json = this.toJSON();
        let result = new Institution();
        result.init(json);
        return result;
    }
}

export interface IInstitution {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    uniqueIdentification: string;
    type: InstitutionType;
    isNational: boolean;
    parentInstitution: Institution;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    address: string;
    contactNumber: string;
    countries: Country[];

    [key: string]: any;
}

export class Country implements ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    code_extended: string;
    name: string;
    description: string;
    sortOrder: number;
    isSystemUse: boolean;
    isCA: boolean;
    flagPath: string;
    registeredDate: moment.Moment;
    isMember: boolean;
    countryStatus: CountryStatus;
    region: string;
    uniqueIdentification: string;
    countrysector: CountrySector[];
    institution: Institution | undefined;
    carboneMarketTool: boolean;
    portfoloaTool: boolean;
    investmentTool: boolean;
    isSingleCountry: number;
    domain: string;

    [key: string]: any;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.countrysector = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.code = _data["code"];
            this.code_extended = _data["code_extended"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.isSystemUse = _data["isSystemUse"];
            this.isCA = _data["isCA"];
            this.flagPath = _data["flagPath"];
            this.registeredDate = _data["registeredDate"] ? moment(_data["registeredDate"].toString()) : <any>undefined;
            this.isMember = _data["isMember"];
            this.countryStatus = _data["countryStatus"];
            this.region = _data["region"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            if (Array.isArray(_data["countrysector"])) {
                this.countrysector = [] as any;
                for (let item of _data["countrysector"])
                    this.countrysector.push(CountrySector.fromJS(item));
            }
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            this.carboneMarketTool = _data["carboneMarketTool"];
            this.portfoloaTool = _data["portfoloaTool"];
            this.investmentTool = _data["investmentTool"];
            this.isSingleCountry = _data["isSingleCountry"];
            this.domain = _data["domain"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["code"] = this.code;
        data["code_extended"] = this.code_extended;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["isSystemUse"] = this.isSystemUse;
        data["isCA"] = this.isCA;
        data["flagPath"] = this.flagPath;
        data["registeredDate"] = this.registeredDate ? this.registeredDate.toISOString() : <any>undefined;
        data["isMember"] = this.isMember;
        data["countryStatus"] = this.countryStatus;
        data["region"] = this.region;
        data["uniqueIdentification"] = this.uniqueIdentification;
        if (Array.isArray(this.countrysector)) {
            data["countrysector"] = [];
            for (let item of this.countrysector)
                data["countrysector"].push(item.toJSON());
        }
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["carboneMarketTool"] = this.carboneMarketTool;
        data["portfoloaTool"] = this.portfoloaTool;
        data["investmentTool"] = this.investmentTool;
        data["isSingleCountry"] = this.isSingleCountry;
        data["domain"] = this.domain;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    code: string;
    code_extended: string;
    name: string;
    description: string;
    sortOrder: number;
    isSystemUse: boolean;
    isCA: boolean;
    flagPath: string;
    registeredDate: moment.Moment;
    isMember: boolean;
    countryStatus: CountryStatus;
    region: string;
    uniqueIdentification: string;
    countrysector: CountrySector[];
    institution: Institution | undefined;
    carboneMarketTool: boolean;
    portfoloaTool: boolean;
    investmentTool: boolean;
    isSingleCountry: number;
    domain: string;

    [key: string]: any;
}

export class CountrySector implements ICountrySector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    country: Country;
    sector: Sector;
    countryId: number;
    sectorId: number;
    uniqueIdentification: string;

    [key: string]: any;

    constructor(data?: ICountrySector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
            this.countryId = _data["countryId"];
            this.sectorId = _data["sectorId"];
            this.uniqueIdentification = _data["uniqueIdentification"];
        }
    }

    static fromJS(data: any): CountrySector {
        data = typeof data === 'object' ? data : {};
        let result = new CountrySector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["countryId"] = this.countryId;
        data["sectorId"] = this.sectorId;
        data["uniqueIdentification"] = this.uniqueIdentification;
        return data;
    }

    clone(): CountrySector {
        const json = this.toJSON();
        let result = new CountrySector();
        result.init(json);
        return result;
    }
}

export interface ICountrySector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    country: Country;
    sector: Sector;
    countryId: number;
    sectorId: number;
    uniqueIdentification: string;

    [key: string]: any;
}

export class Indicator implements IIndicator {
    id: number;
    name: string;
    sectors: Sector[];

    [key: string]: any;

    constructor(data?: IIndicator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sectors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["sectors"])) {
                this.sectors = [] as any;
                for (let item of _data["sectors"])
                    this.sectors.push(Sector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Indicator {
        data = typeof data === 'object' ? data : {};
        let result = new Indicator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.sectors)) {
            data["sectors"] = [];
            for (let item of this.sectors)
                data["sectors"].push(item.toJSON());
        }
        return data;
    }

    clone(): Indicator {
        const json = this.toJSON();
        let result = new Indicator();
        result.init(json);
        return result;
    }
}

export interface IIndicator {
    id: number;
    name: string;
    sectors: Sector[];

    [key: string]: any;
}

export class SectorIndicator implements ISectorIndicator {
    id: number;
    sector: Sector;
    indicator: Indicator;

    [key: string]: any;

    constructor(data?: ISectorIndicator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sector = new Sector();
            this.indicator = new Indicator();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
            this.indicator = _data["indicator"] ? Indicator.fromJS(_data["indicator"]) : new Indicator();
        }
    }

    static fromJS(data: any): SectorIndicator {
        data = typeof data === 'object' ? data : {};
        let result = new SectorIndicator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>undefined;
        return data;
    }

    clone(): SectorIndicator {
        const json = this.toJSON();
        let result = new SectorIndicator();
        result.init(json);
        return result;
    }
}

export interface ISectorIndicator {
    id: number;
    sector: Sector;
    indicator: Indicator;

    [key: string]: any;
}

export class GetManyLearningMaterialResponseDto implements IGetManyLearningMaterialResponseDto {
    data: LearningMaterial[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyLearningMaterialResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(LearningMaterial.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyLearningMaterialResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyLearningMaterialResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyLearningMaterialResponseDto {
        const json = this.toJSON();
        let result = new GetManyLearningMaterialResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyLearningMaterialResponseDto {
    data: LearningMaterial[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyUserTypeResponseDto implements IGetManyUserTypeResponseDto {
    data: UserType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyUserTypeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UserType.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUserTypeResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserTypeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserTypeResponseDto {
    data: UserType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class UserType implements IUserType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    learningMaterialusertype: LearningMaterialUserType[];
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IUserType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.learningMaterialusertype = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["learningMaterialusertype"])) {
                this.learningMaterialusertype = [] as any;
                for (let item of _data["learningMaterialusertype"])
                    this.learningMaterialusertype.push(LearningMaterialUserType.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): UserType {
        data = typeof data === 'object' ? data : {};
        let result = new UserType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.learningMaterialusertype)) {
            data["learningMaterialusertype"] = [];
            for (let item of this.learningMaterialusertype)
                data["learningMaterialusertype"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): UserType {
        const json = this.toJSON();
        let result = new UserType();
        result.init(json);
        return result;
    }
}

export interface IUserType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    learningMaterialusertype: LearningMaterialUserType[];
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class LearningMaterialUserType implements ILearningMaterialUserType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    learningMaterial: LearningMaterial;
    userType: UserType;
    userid: number;

    [key: string]: any;

    constructor(data?: ILearningMaterialUserType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.learningMaterial = new LearningMaterial();
            this.userType = new UserType();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.learningMaterial = _data["learningMaterial"] ? LearningMaterial.fromJS(_data["learningMaterial"]) : new LearningMaterial();
            this.userType = _data["userType"] ? UserType.fromJS(_data["userType"]) : new UserType();
            this.userid = _data["userid"];
        }
    }

    static fromJS(data: any): LearningMaterialUserType {
        data = typeof data === 'object' ? data : {};
        let result = new LearningMaterialUserType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["learningMaterial"] = this.learningMaterial ? this.learningMaterial.toJSON() : <any>undefined;
        data["userType"] = this.userType ? this.userType.toJSON() : <any>undefined;
        data["userid"] = this.userid;
        return data;
    }

    clone(): LearningMaterialUserType {
        const json = this.toJSON();
        let result = new LearningMaterialUserType();
        result.init(json);
        return result;
    }
}

export interface ILearningMaterialUserType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    learningMaterial: LearningMaterial;
    userType: UserType;
    userid: number;

    [key: string]: any;
}

export class LearningMaterial implements ILearningMaterial {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    documentType: string;
    documentName: string;
    document: string;
    thumbnail: string;
    isPublish: boolean;
    deletedAt: moment.Moment;
    uniqueIdentification: string;
    learningMaterialusertype: LearningMaterialUserType[];
    learningMaterialsector: LearningMaterialSector[];

    [key: string]: any;

    constructor(data?: ILearningMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.learningMaterialusertype = [];
            this.learningMaterialsector = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.documentType = _data["documentType"];
            this.documentName = _data["documentName"];
            this.document = _data["document"];
            this.thumbnail = _data["thumbnail"];
            this.isPublish = _data["isPublish"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.uniqueIdentification = _data["uniqueIdentification"];
            if (Array.isArray(_data["learningMaterialusertype"])) {
                this.learningMaterialusertype = [] as any;
                for (let item of _data["learningMaterialusertype"])
                    this.learningMaterialusertype.push(LearningMaterialUserType.fromJS(item));
            }
            if (Array.isArray(_data["learningMaterialsector"])) {
                this.learningMaterialsector = [] as any;
                for (let item of _data["learningMaterialsector"])
                    this.learningMaterialsector.push(LearningMaterialSector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LearningMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new LearningMaterial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["documentType"] = this.documentType;
        data["documentName"] = this.documentName;
        data["document"] = this.document;
        data["thumbnail"] = this.thumbnail;
        data["isPublish"] = this.isPublish;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["uniqueIdentification"] = this.uniqueIdentification;
        if (Array.isArray(this.learningMaterialusertype)) {
            data["learningMaterialusertype"] = [];
            for (let item of this.learningMaterialusertype)
                data["learningMaterialusertype"].push(item.toJSON());
        }
        if (Array.isArray(this.learningMaterialsector)) {
            data["learningMaterialsector"] = [];
            for (let item of this.learningMaterialsector)
                data["learningMaterialsector"].push(item.toJSON());
        }
        return data;
    }

    clone(): LearningMaterial {
        const json = this.toJSON();
        let result = new LearningMaterial();
        result.init(json);
        return result;
    }
}

export interface ILearningMaterial {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    documentType: string;
    documentName: string;
    document: string;
    thumbnail: string;
    isPublish: boolean;
    deletedAt: moment.Moment;
    uniqueIdentification: string;
    learningMaterialusertype: LearningMaterialUserType[];
    learningMaterialsector: LearningMaterialSector[];

    [key: string]: any;
}

export class LearningMaterialSector implements ILearningMaterialSector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    learningMaterial2: LearningMaterial;
    sector: Sector;

    [key: string]: any;

    constructor(data?: ILearningMaterialSector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.learningMaterial2 = new LearningMaterial();
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.learningMaterial2 = _data["learningMaterial2"] ? LearningMaterial.fromJS(_data["learningMaterial2"]) : new LearningMaterial();
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
        }
    }

    static fromJS(data: any): LearningMaterialSector {
        data = typeof data === 'object' ? data : {};
        let result = new LearningMaterialSector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["learningMaterial2"] = this.learningMaterial2 ? this.learningMaterial2.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        return data;
    }

    clone(): LearningMaterialSector {
        const json = this.toJSON();
        let result = new LearningMaterialSector();
        result.init(json);
        return result;
    }
}

export interface ILearningMaterialSector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    learningMaterial2: LearningMaterial;
    sector: Sector;

    [key: string]: any;
}

export class SubSector implements ISubSector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    sector: Sector;

    [key: string]: any;

    constructor(data?: ISubSector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
        }
    }

    static fromJS(data: any): SubSector {
        data = typeof data === 'object' ? data : {};
        let result = new SubSector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        return data;
    }

    clone(): SubSector {
        const json = this.toJSON();
        let result = new SubSector();
        result.init(json);
        return result;
    }
}

export interface ISubSector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    sector: Sector;

    [key: string]: any;
}

export class Sector implements ISector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    countrysector: CountrySector[];
    sectorindicator: SectorIndicator[];
    learningMaterialsector: LearningMaterialSector[];
    subSector: SubSector[];
    uniqueIdentification: string;
    indicators: Indicator[];

    [key: string]: any;

    constructor(data?: ISector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.countrysector = [];
            this.sectorindicator = [];
            this.learningMaterialsector = [];
            this.subSector = [];
            this.indicators = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["countrysector"])) {
                this.countrysector = [] as any;
                for (let item of _data["countrysector"])
                    this.countrysector.push(CountrySector.fromJS(item));
            }
            if (Array.isArray(_data["sectorindicator"])) {
                this.sectorindicator = [] as any;
                for (let item of _data["sectorindicator"])
                    this.sectorindicator.push(SectorIndicator.fromJS(item));
            }
            if (Array.isArray(_data["learningMaterialsector"])) {
                this.learningMaterialsector = [] as any;
                for (let item of _data["learningMaterialsector"])
                    this.learningMaterialsector.push(LearningMaterialSector.fromJS(item));
            }
            if (Array.isArray(_data["subSector"])) {
                this.subSector = [] as any;
                for (let item of _data["subSector"])
                    this.subSector.push(SubSector.fromJS(item));
            }
            this.uniqueIdentification = _data["uniqueIdentification"];
            if (Array.isArray(_data["indicators"])) {
                this.indicators = [] as any;
                for (let item of _data["indicators"])
                    this.indicators.push(Indicator.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.countrysector)) {
            data["countrysector"] = [];
            for (let item of this.countrysector)
                data["countrysector"].push(item.toJSON());
        }
        if (Array.isArray(this.sectorindicator)) {
            data["sectorindicator"] = [];
            for (let item of this.sectorindicator)
                data["sectorindicator"].push(item.toJSON());
        }
        if (Array.isArray(this.learningMaterialsector)) {
            data["learningMaterialsector"] = [];
            for (let item of this.learningMaterialsector)
                data["learningMaterialsector"].push(item.toJSON());
        }
        if (Array.isArray(this.subSector)) {
            data["subSector"] = [];
            for (let item of this.subSector)
                data["subSector"].push(item.toJSON());
        }
        data["uniqueIdentification"] = this.uniqueIdentification;
        if (Array.isArray(this.indicators)) {
            data["indicators"] = [];
            for (let item of this.indicators)
                data["indicators"].push(item.toJSON());
        }
        return data;
    }

    clone(): Sector {
        const json = this.toJSON();
        let result = new Sector();
        result.init(json);
        return result;
    }
}

export interface ISector {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    countrysector: CountrySector[];
    sectorindicator: SectorIndicator[];
    learningMaterialsector: LearningMaterialSector[];
    subSector: SubSector[];
    uniqueIdentification: string;
    indicators: Indicator[];

    [key: string]: any;
}

export class GetManyMitigationActionTypeResponseDto implements IGetManyMitigationActionTypeResponseDto {
    data: MitigationActionType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyMitigationActionTypeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(MitigationActionType.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMitigationActionTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMitigationActionTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMitigationActionTypeResponseDto {
        const json = this.toJSON();
        let result = new GetManyMitigationActionTypeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMitigationActionTypeResponseDto {
    data: MitigationActionType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class MitigationActionType implements IMitigationActionType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    uniqueIdentification: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IMitigationActionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): MitigationActionType {
        data = typeof data === 'object' ? data : {};
        let result = new MitigationActionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): MitigationActionType {
        const json = this.toJSON();
        let result = new MitigationActionType();
        result.init(json);
        return result;
    }
}

export interface IMitigationActionType {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    uniqueIdentification: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyApplicabilityEntityResponseDto implements IGetManyApplicabilityEntityResponseDto {
    data: ApplicabilityEntity[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyApplicabilityEntityResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ApplicabilityEntity.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyApplicabilityEntityResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyApplicabilityEntityResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyApplicabilityEntityResponseDto {
        const json = this.toJSON();
        let result = new GetManyApplicabilityEntityResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyApplicabilityEntityResponseDto {
    data: ApplicabilityEntity[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class ApplicabilityEntity implements IApplicabilityEntity {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    uniqueIdentification: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IApplicabilityEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): ApplicabilityEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicabilityEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): ApplicabilityEntity {
        const json = this.toJSON();
        let result = new ApplicabilityEntity();
        result.init(json);
        return result;
    }
}

export interface IApplicabilityEntity {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    uniqueIdentification: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class MethodologyData implements IMethodologyData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    version: string;
    name: string;
    displayName: string;
    developedBy: string;
    parentId: number;
    applicableSector: string;
    documents: string;
    easenessOfDataCollection: string;
    transportSubSector: string;
    upstream_downstream: string;
    ghgIncluded: string;
    uniqueIdentification: string;
    sector: Sector;
    indicator: Indicator;
    mitigationActionType: MitigationActionType;
    applicability: ApplicabilityEntity;
    baselineImage: string;
    projectImage: string;
    projectionImage: string;
    leakageImage: string;
    resultImage: string;

    [key: string]: any;

    constructor(data?: IMethodologyData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.version = _data["version"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.developedBy = _data["developedBy"];
            this.parentId = _data["parentId"];
            this.applicableSector = _data["applicableSector"];
            this.documents = _data["documents"];
            this.easenessOfDataCollection = _data["easenessOfDataCollection"];
            this.transportSubSector = _data["transportSubSector"];
            this.upstream_downstream = _data["upstream_downstream"];
            this.ghgIncluded = _data["ghgIncluded"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.indicator = _data["indicator"] ? Indicator.fromJS(_data["indicator"]) : <any>undefined;
            this.mitigationActionType = _data["mitigationActionType"] ? MitigationActionType.fromJS(_data["mitigationActionType"]) : <any>undefined;
            this.applicability = _data["applicability"] ? ApplicabilityEntity.fromJS(_data["applicability"]) : <any>undefined;
            this.baselineImage = _data["baselineImage"];
            this.projectImage = _data["projectImage"];
            this.projectionImage = _data["projectionImage"];
            this.leakageImage = _data["leakageImage"];
            this.resultImage = _data["resultImage"];
        }
    }

    static fromJS(data: any): MethodologyData {
        data = typeof data === 'object' ? data : {};
        let result = new MethodologyData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["version"] = this.version;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["developedBy"] = this.developedBy;
        data["parentId"] = this.parentId;
        data["applicableSector"] = this.applicableSector;
        data["documents"] = this.documents;
        data["easenessOfDataCollection"] = this.easenessOfDataCollection;
        data["transportSubSector"] = this.transportSubSector;
        data["upstream_downstream"] = this.upstream_downstream;
        data["ghgIncluded"] = this.ghgIncluded;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>undefined;
        data["mitigationActionType"] = this.mitigationActionType ? this.mitigationActionType.toJSON() : <any>undefined;
        data["applicability"] = this.applicability ? this.applicability.toJSON() : <any>undefined;
        data["baselineImage"] = this.baselineImage;
        data["projectImage"] = this.projectImage;
        data["projectionImage"] = this.projectionImage;
        data["leakageImage"] = this.leakageImage;
        data["resultImage"] = this.resultImage;
        return data;
    }

    clone(): MethodologyData {
        const json = this.toJSON();
        let result = new MethodologyData();
        result.init(json);
        return result;
    }
}

export interface IMethodologyData {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    version: string;
    name: string;
    displayName: string;
    developedBy: string;
    parentId: number;
    applicableSector: string;
    documents: string;
    easenessOfDataCollection: string;
    transportSubSector: string;
    upstream_downstream: string;
    ghgIncluded: string;
    uniqueIdentification: string;
    sector: Sector;
    indicator: Indicator;
    mitigationActionType: MitigationActionType;
    applicability: ApplicabilityEntity;
    baselineImage: string;
    projectImage: string;
    projectionImage: string;
    leakageImage: string;
    resultImage: string;

    [key: string]: any;
}

export class GetManyMethodologyResponseDto implements IGetManyMethodologyResponseDto {
    data: Methodology[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyMethodologyResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Methodology.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMethodologyResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMethodologyResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyMethodologyResponseDto {
        const json = this.toJSON();
        let result = new GetManyMethodologyResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMethodologyResponseDto {
    data: Methodology[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class Methodology implements IMethodology {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    version: string;
    name: string;
    displayName: string;
    developedBy: string;
    parentId: number;
    applicableSector: string;
    documents: string;
    isActive: MethodologyIsActive;
    easenessOfDataCollection: string;
    transportSubSector: string;
    upstream_downstream: string;
    ghgIncluded: string;
    uniqueIdentification: string;
    country: Country;
    indicator: Indicator;
    sector: Sector;
    mitigationActionType: MitigationActionType;
    applicability: ApplicabilityEntity;
    method: MethodologyData;

    [key: string]: any;

    constructor(data?: IMethodology) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.version = _data["version"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.developedBy = _data["developedBy"];
            this.parentId = _data["parentId"];
            this.applicableSector = _data["applicableSector"];
            this.documents = _data["documents"];
            this.isActive = _data["isActive"];
            this.easenessOfDataCollection = _data["easenessOfDataCollection"];
            this.transportSubSector = _data["transportSubSector"];
            this.upstream_downstream = _data["upstream_downstream"];
            this.ghgIncluded = _data["ghgIncluded"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.indicator = _data["indicator"] ? Indicator.fromJS(_data["indicator"]) : <any>undefined;
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.mitigationActionType = _data["mitigationActionType"] ? MitigationActionType.fromJS(_data["mitigationActionType"]) : <any>undefined;
            this.applicability = _data["applicability"] ? ApplicabilityEntity.fromJS(_data["applicability"]) : <any>undefined;
            this.method = _data["method"] ? MethodologyData.fromJS(_data["method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Methodology {
        data = typeof data === 'object' ? data : {};
        let result = new Methodology();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["version"] = this.version;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["developedBy"] = this.developedBy;
        data["parentId"] = this.parentId;
        data["applicableSector"] = this.applicableSector;
        data["documents"] = this.documents;
        data["isActive"] = this.isActive;
        data["easenessOfDataCollection"] = this.easenessOfDataCollection;
        data["transportSubSector"] = this.transportSubSector;
        data["upstream_downstream"] = this.upstream_downstream;
        data["ghgIncluded"] = this.ghgIncluded;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["indicator"] = this.indicator ? this.indicator.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["mitigationActionType"] = this.mitigationActionType ? this.mitigationActionType.toJSON() : <any>undefined;
        data["applicability"] = this.applicability ? this.applicability.toJSON() : <any>undefined;
        data["method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }

    clone(): Methodology {
        const json = this.toJSON();
        let result = new Methodology();
        result.init(json);
        return result;
    }
}

export interface IMethodology {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    version: string;
    name: string;
    displayName: string;
    developedBy: string;
    parentId: number;
    applicableSector: string;
    documents: string;
    isActive: MethodologyIsActive;
    easenessOfDataCollection: string;
    transportSubSector: string;
    upstream_downstream: string;
    ghgIncluded: string;
    uniqueIdentification: string;
    country: Country;
    indicator: Indicator;
    sector: Sector;
    mitigationActionType: MitigationActionType;
    applicability: ApplicabilityEntity;
    method: MethodologyData;

    [key: string]: any;
}

export class GetManyEmissionReductioDraftDataEntityResponseDto implements IGetManyEmissionReductioDraftDataEntityResponseDto {
    data: EmissionReductioDraftDataEntity[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyEmissionReductioDraftDataEntityResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(EmissionReductioDraftDataEntity.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyEmissionReductioDraftDataEntityResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyEmissionReductioDraftDataEntityResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyEmissionReductioDraftDataEntityResponseDto {
        const json = this.toJSON();
        let result = new GetManyEmissionReductioDraftDataEntityResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyEmissionReductioDraftDataEntityResponseDto {
    data: EmissionReductioDraftDataEntity[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class EmissionReductioDraftDataEntity implements IEmissionReductioDraftDataEntity {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    country: Country;
    sector: Sector;
    baseYear: string;
    baseYearEmission: number;
    targetYear: string;
    targetYearEmission: number;
    unconditionaltco2: number;
    conditionaltco2: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IEmissionReductioDraftDataEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
            this.baseYear = _data["baseYear"];
            this.baseYearEmission = _data["baseYearEmission"];
            this.targetYear = _data["targetYear"];
            this.targetYearEmission = _data["targetYearEmission"];
            this.unconditionaltco2 = _data["unconditionaltco2"];
            this.conditionaltco2 = _data["conditionaltco2"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): EmissionReductioDraftDataEntity {
        data = typeof data === 'object' ? data : {};
        let result = new EmissionReductioDraftDataEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["baseYear"] = this.baseYear;
        data["baseYearEmission"] = this.baseYearEmission;
        data["targetYear"] = this.targetYear;
        data["targetYearEmission"] = this.targetYearEmission;
        data["unconditionaltco2"] = this.unconditionaltco2;
        data["conditionaltco2"] = this.conditionaltco2;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): EmissionReductioDraftDataEntity {
        const json = this.toJSON();
        let result = new EmissionReductioDraftDataEntity();
        result.init(json);
        return result;
    }
}

export interface IEmissionReductioDraftDataEntity {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    country: Country;
    sector: Sector;
    baseYear: string;
    baseYearEmission: number;
    targetYear: string;
    targetYearEmission: number;
    unconditionaltco2: number;
    conditionaltco2: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyReportResponseDto implements IGetManyReportResponseDto {
    data: Report[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyReportResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Report.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyReportResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyReportResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyReportResponseDto {
        const json = this.toJSON();
        let result = new GetManyReportResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyReportResponseDto {
    data: Report[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class Report implements IReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reportName: string;
    savedLocation: string;
    country: Country;
    description: string;
    isPublish: number;
    thumbnail: string;

    [key: string]: any;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.reportName = _data["reportName"];
            this.savedLocation = _data["savedLocation"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.description = _data["description"];
            this.isPublish = _data["isPublish"];
            this.thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["reportName"] = this.reportName;
        data["savedLocation"] = this.savedLocation;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["isPublish"] = this.isPublish;
        data["thumbnail"] = this.thumbnail;
        return data;
    }

    clone(): Report {
        const json = this.toJSON();
        let result = new Report();
        result.init(json);
        return result;
    }
}

export interface IReport {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    reportName: string;
    savedLocation: string;
    country: Country;
    description: string;
    isPublish: number;
    thumbnail: string;

    [key: string]: any;
}

export class AuditDto implements IAuditDto {

    [key: string]: any;

    constructor(data?: IAuditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AuditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): AuditDto {
        const json = this.toJSON();
        let result = new AuditDto();
        result.init(json);
        return result;
    }
}

export interface IAuditDto {

    [key: string]: any;
}

export class GetManyAuditResponseDto implements IGetManyAuditResponseDto {
    data: Audit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyAuditResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Audit.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyAuditResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyAuditResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyAuditResponseDto {
        const json = this.toJSON();
        let result = new GetManyAuditResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyAuditResponseDto {
    data: Audit[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyUserResponseDto implements IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyUserResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(User.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUserResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class User implements IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    userType: UserType;
    firstName: string;
    lastName: string;
    username: string;
    email: string;
    institution: Institution;
    telephone: string;
    mobile: string;
    mrvInstitution: string;
    country: Country;
    salt: string;
    password: string;
    resetToken: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    fullName: string;
    _fullname: string;

    [key: string]: any;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userType = new UserType();
            this.institution = new Institution();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.uniqueIdentification = _data["uniqueIdentification"];
            this.userType = _data["userType"] ? UserType.fromJS(_data["userType"]) : new UserType();
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : new Institution();
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.mrvInstitution = _data["mrvInstitution"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.salt = _data["salt"];
            this.password = _data["password"];
            this.resetToken = _data["resetToken"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.fullName = _data["fullName"];
            this._fullname = _data["_fullname"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["uniqueIdentification"] = this.uniqueIdentification;
        data["userType"] = this.userType ? this.userType.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["email"] = this.email;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["mrvInstitution"] = this.mrvInstitution;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["salt"] = this.salt;
        data["password"] = this.password;
        data["resetToken"] = this.resetToken;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["fullName"] = this.fullName;
        data["_fullname"] = this._fullname;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    uniqueIdentification: string;
    userType: UserType;
    firstName: string;
    lastName: string;
    username: string;
    email: string;
    institution: Institution;
    telephone: string;
    mobile: string;
    mrvInstitution: string;
    country: Country;
    salt: string;
    password: string;
    resetToken: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    fullName: string;
    _fullname: string;

    [key: string]: any;
}

export class Audit implements IAudit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    userName: string;
    action: string;
    comment: string;
    actionStatus: string;
    userType: string;

    [key: string]: any;

    constructor(data?: IAudit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.userName = _data["userName"];
            this.action = _data["action"];
            this.comment = _data["comment"];
            this.actionStatus = _data["actionStatus"];
            this.userType = _data["userType"];
        }
    }

    static fromJS(data: any): Audit {
        data = typeof data === 'object' ? data : {};
        let result = new Audit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["action"] = this.action;
        data["comment"] = this.comment;
        data["actionStatus"] = this.actionStatus;
        data["userType"] = this.userType;
        return data;
    }

    clone(): Audit {
        const json = this.toJSON();
        let result = new Audit();
        result.init(json);
        return result;
    }
}

export interface IAudit {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    userName: string;
    action: string;
    comment: string;
    actionStatus: string;
    userType: string;

    [key: string]: any;
}

export class GetManyProjectResponseDto implements IGetManyProjectResponseDto {
    data: Project[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyProjectResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Project.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectResponseDto {
    data: Project[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManyProjectStatusResponseDto implements IGetManyProjectStatusResponseDto {
    data: ProjectStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyProjectStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectStatus.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectStatusResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectStatusResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectStatusResponseDto {
    data: ProjectStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class ProjectStatus implements IProjectStatus {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IProjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): ProjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): ProjectStatus {
        const json = this.toJSON();
        let result = new ProjectStatus();
        result.init(json);
        return result;
    }
}

export interface IProjectStatus {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyNdcResponseDto implements IGetManyNdcResponseDto {
    data: Ndc[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyNdcResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Ndc.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNdcResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNdcResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNdcResponseDto {
        const json = this.toJSON();
        let result = new GetManyNdcResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNdcResponseDto {
    data: Ndc[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class GetManySubNdcResponseDto implements IGetManySubNdcResponseDto {
    data: SubNdc[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManySubNdcResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SubNdc.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySubNdcResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySubNdcResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManySubNdcResponseDto {
        const json = this.toJSON();
        let result = new GetManySubNdcResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySubNdcResponseDto {
    data: SubNdc[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class SubNdc implements ISubNdc {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    ndc: Ndc;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: ISubNdc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ndc = new Ndc();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.ndc = _data["ndc"] ? Ndc.fromJS(_data["ndc"]) : new Ndc();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): SubNdc {
        data = typeof data === 'object' ? data : {};
        let result = new SubNdc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["ndc"] = this.ndc ? this.ndc.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): SubNdc {
        const json = this.toJSON();
        let result = new SubNdc();
        result.init(json);
        return result;
    }
}

export interface ISubNdc {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    ndc: Ndc;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyNdcSetResponseDto implements IGetManyNdcSetResponseDto {
    data: NdcSet[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyNdcSetResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(NdcSet.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyNdcSetResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyNdcSetResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyNdcSetResponseDto {
        const json = this.toJSON();
        let result = new GetManyNdcSetResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyNdcSetResponseDto {
    data: NdcSet[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class NdcSet implements INdcSet {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    country: Country;
    submissionDate: moment.Moment;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: INdcSet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.country = new Country();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.submissionDate = _data["submissionDate"] ? moment(_data["submissionDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): NdcSet {
        data = typeof data === 'object' ? data : {};
        let result = new NdcSet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["submissionDate"] = this.submissionDate ? this.submissionDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): NdcSet {
        const json = this.toJSON();
        let result = new NdcSet();
        result.init(json);
        return result;
    }
}

export interface INdcSet {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    country: Country;
    submissionDate: moment.Moment;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class Ndc implements INdc {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    subNdc: SubNdc[];
    set: NdcSet;
    country: Country;
    sector: Sector;
    isSelected: boolean;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: INdc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.subNdc = [];
            this.set = new NdcSet();
            this.country = new Country();
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            if (Array.isArray(_data["subNdc"])) {
                this.subNdc = [] as any;
                for (let item of _data["subNdc"])
                    this.subNdc.push(SubNdc.fromJS(item));
            }
            this.set = _data["set"] ? NdcSet.fromJS(_data["set"]) : new NdcSet();
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : new Country();
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
            this.isSelected = _data["isSelected"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): Ndc {
        data = typeof data === 'object' ? data : {};
        let result = new Ndc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        if (Array.isArray(this.subNdc)) {
            data["subNdc"] = [];
            for (let item of this.subNdc)
                data["subNdc"].push(item.toJSON());
        }
        data["set"] = this.set ? this.set.toJSON() : <any>undefined;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["isSelected"] = this.isSelected;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): Ndc {
        const json = this.toJSON();
        let result = new Ndc();
        result.init(json);
        return result;
    }
}

export interface INdc {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    subNdc: SubNdc[];
    set: NdcSet;
    country: Country;
    sector: Sector;
    isSelected: boolean;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyProjectOwnerResponseDto implements IGetManyProjectOwnerResponseDto {
    data: ProjectOwner[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyProjectOwnerResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectOwner.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectOwnerResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectOwnerResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectOwnerResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectOwnerResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectOwnerResponseDto {
    data: ProjectOwner[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class ProjectOwner implements IProjectOwner {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IProjectOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): ProjectOwner {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): ProjectOwner {
        const json = this.toJSON();
        let result = new ProjectOwner();
        result.init(json);
        return result;
    }
}

export interface IProjectOwner {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class GetManyProjectApprovalStatusResponseDto implements IGetManyProjectApprovalStatusResponseDto {
    data: ProjectApprovalStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyProjectApprovalStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectApprovalStatus.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectApprovalStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectApprovalStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyProjectApprovalStatusResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectApprovalStatusResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectApprovalStatusResponseDto {
    data: ProjectApprovalStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class ProjectApprovalStatus implements IProjectApprovalStatus {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IProjectApprovalStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): ProjectApprovalStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectApprovalStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): ProjectApprovalStatus {
        const json = this.toJSON();
        let result = new ProjectApprovalStatus();
        result.init(json);
        return result;
    }
}

export interface IProjectApprovalStatus {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class Project implements IProject {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    climateActionName: string;
    description: string;
    contactPersoFullName: string;
    email: string;
    contactPersonDesignation: string;
    telephoneNumber: string;
    mobileNumber: string;
    institution: string;
    mappedInstitution: Institution;
    country: Country;
    projectStatus: ProjectStatus;
    sector: Sector;
    ndc: Ndc;
    subNdc: SubNdc;
    projectScope: string;
    projectOwner: ProjectOwner;
    acceptedDate: moment.Moment;
    proposeDateofCommence: moment.Moment;
    duration: number;
    objective: string;
    subNationalLevl1: string;
    subNationalLevl2: string;
    subNationalLevl3: string;
    longitude: number;
    latitude: number;
    outcome: string;
    currentProgress: string;
    chgEmissions: string;
    adaptationBenefits: string;
    directSDBenefit: string;
    indirectSDBenefit: string;
    implementingEntity: string;
    executingEntity: string;
    partiesInvolved: string;
    beneficiaries: string;
    financingScheme: FinancingScheme;
    donors: string;
    investors: string;
    fundingOrganization: string;
    initialInvestment: number;
    annualFunding: number;
    annualRevenue: number;
    expectedRecurrentExpenditure: any;
    mitigationActionType: MitigationActionType;
    projectApprovalStatus: ProjectApprovalStatus;
    projectRejectComment: string;
    projectDataRequsetComment: string;

    [key: string]: any;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.climateActionName = _data["climateActionName"];
            this.description = _data["description"];
            this.contactPersoFullName = _data["contactPersoFullName"];
            this.email = _data["email"];
            this.contactPersonDesignation = _data["contactPersonDesignation"];
            this.telephoneNumber = _data["telephoneNumber"];
            this.mobileNumber = _data["mobileNumber"];
            this.institution = _data["institution"];
            this.mappedInstitution = _data["mappedInstitution"] ? Institution.fromJS(_data["mappedInstitution"]) : <any>undefined;
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>undefined;
            this.projectStatus = _data["projectStatus"] ? ProjectStatus.fromJS(_data["projectStatus"]) : <any>undefined;
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.ndc = _data["ndc"] ? Ndc.fromJS(_data["ndc"]) : <any>undefined;
            this.subNdc = _data["subNdc"] ? SubNdc.fromJS(_data["subNdc"]) : <any>undefined;
            this.projectScope = _data["projectScope"];
            this.projectOwner = _data["projectOwner"] ? ProjectOwner.fromJS(_data["projectOwner"]) : <any>undefined;
            this.acceptedDate = _data["acceptedDate"] ? moment(_data["acceptedDate"].toString()) : <any>undefined;
            this.proposeDateofCommence = _data["proposeDateofCommence"] ? moment(_data["proposeDateofCommence"].toString()) : <any>undefined;
            this.duration = _data["duration"];
            this.objective = _data["objective"];
            this.subNationalLevl1 = _data["subNationalLevl1"];
            this.subNationalLevl2 = _data["subNationalLevl2"];
            this.subNationalLevl3 = _data["subNationalLevl3"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.outcome = _data["outcome"];
            this.currentProgress = _data["currentProgress"];
            this.chgEmissions = _data["chgEmissions"];
            this.adaptationBenefits = _data["adaptationBenefits"];
            this.directSDBenefit = _data["directSDBenefit"];
            this.indirectSDBenefit = _data["indirectSDBenefit"];
            this.implementingEntity = _data["implementingEntity"];
            this.executingEntity = _data["executingEntity"];
            this.partiesInvolved = _data["partiesInvolved"];
            this.beneficiaries = _data["beneficiaries"];
            this.financingScheme = _data["financingScheme"] ? FinancingScheme.fromJS(_data["financingScheme"]) : <any>undefined;
            this.donors = _data["donors"];
            this.investors = _data["investors"];
            this.fundingOrganization = _data["fundingOrganization"];
            this.initialInvestment = _data["initialInvestment"];
            this.annualFunding = _data["annualFunding"];
            this.annualRevenue = _data["annualRevenue"];
            this.expectedRecurrentExpenditure = _data["expectedRecurrentExpenditure"];
            this.mitigationActionType = _data["mitigationActionType"] ? MitigationActionType.fromJS(_data["mitigationActionType"]) : <any>undefined;
            this.projectApprovalStatus = _data["projectApprovalStatus"] ? ProjectApprovalStatus.fromJS(_data["projectApprovalStatus"]) : <any>undefined;
            this.projectRejectComment = _data["projectRejectComment"];
            this.projectDataRequsetComment = _data["projectDataRequsetComment"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["climateActionName"] = this.climateActionName;
        data["description"] = this.description;
        data["contactPersoFullName"] = this.contactPersoFullName;
        data["email"] = this.email;
        data["contactPersonDesignation"] = this.contactPersonDesignation;
        data["telephoneNumber"] = this.telephoneNumber;
        data["mobileNumber"] = this.mobileNumber;
        data["institution"] = this.institution;
        data["mappedInstitution"] = this.mappedInstitution ? this.mappedInstitution.toJSON() : <any>undefined;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["projectStatus"] = this.projectStatus ? this.projectStatus.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["ndc"] = this.ndc ? this.ndc.toJSON() : <any>undefined;
        data["subNdc"] = this.subNdc ? this.subNdc.toJSON() : <any>undefined;
        data["projectScope"] = this.projectScope;
        data["projectOwner"] = this.projectOwner ? this.projectOwner.toJSON() : <any>undefined;
        data["acceptedDate"] = this.acceptedDate ? this.acceptedDate.toISOString() : <any>undefined;
        data["proposeDateofCommence"] = this.proposeDateofCommence ? this.proposeDateofCommence.toISOString() : <any>undefined;
        data["duration"] = this.duration;
        data["objective"] = this.objective;
        data["subNationalLevl1"] = this.subNationalLevl1;
        data["subNationalLevl2"] = this.subNationalLevl2;
        data["subNationalLevl3"] = this.subNationalLevl3;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["outcome"] = this.outcome;
        data["currentProgress"] = this.currentProgress;
        data["chgEmissions"] = this.chgEmissions;
        data["adaptationBenefits"] = this.adaptationBenefits;
        data["directSDBenefit"] = this.directSDBenefit;
        data["indirectSDBenefit"] = this.indirectSDBenefit;
        data["implementingEntity"] = this.implementingEntity;
        data["executingEntity"] = this.executingEntity;
        data["partiesInvolved"] = this.partiesInvolved;
        data["beneficiaries"] = this.beneficiaries;
        data["financingScheme"] = this.financingScheme ? this.financingScheme.toJSON() : <any>undefined;
        data["donors"] = this.donors;
        data["investors"] = this.investors;
        data["fundingOrganization"] = this.fundingOrganization;
        data["initialInvestment"] = this.initialInvestment;
        data["annualFunding"] = this.annualFunding;
        data["annualRevenue"] = this.annualRevenue;
        data["expectedRecurrentExpenditure"] = this.expectedRecurrentExpenditure;
        data["mitigationActionType"] = this.mitigationActionType ? this.mitigationActionType.toJSON() : <any>undefined;
        data["projectApprovalStatus"] = this.projectApprovalStatus ? this.projectApprovalStatus.toJSON() : <any>undefined;
        data["projectRejectComment"] = this.projectRejectComment;
        data["projectDataRequsetComment"] = this.projectDataRequsetComment;
        return data;
    }

    clone(): Project {
        const json = this.toJSON();
        let result = new Project();
        result.init(json);
        return result;
    }
}

export interface IProject {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    climateActionName: string;
    description: string;
    contactPersoFullName: string;
    email: string;
    contactPersonDesignation: string;
    telephoneNumber: string;
    mobileNumber: string;
    institution: string;
    mappedInstitution: Institution;
    country: Country;
    projectStatus: ProjectStatus;
    sector: Sector;
    ndc: Ndc;
    subNdc: SubNdc;
    projectScope: string;
    projectOwner: ProjectOwner;
    acceptedDate: moment.Moment;
    proposeDateofCommence: moment.Moment;
    duration: number;
    objective: string;
    subNationalLevl1: string;
    subNationalLevl2: string;
    subNationalLevl3: string;
    longitude: number;
    latitude: number;
    outcome: string;
    currentProgress: string;
    chgEmissions: string;
    adaptationBenefits: string;
    directSDBenefit: string;
    indirectSDBenefit: string;
    implementingEntity: string;
    executingEntity: string;
    partiesInvolved: string;
    beneficiaries: string;
    financingScheme: FinancingScheme;
    donors: string;
    investors: string;
    fundingOrganization: string;
    initialInvestment: number;
    annualFunding: number;
    annualRevenue: number;
    expectedRecurrentExpenditure: any;
    mitigationActionType: MitigationActionType;
    projectApprovalStatus: ProjectApprovalStatus;
    projectRejectComment: string;
    projectDataRequsetComment: string;

    [key: string]: any;
}

export class GetManyDocumentsResponseDto implements IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyDocumentsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Documents.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDocumentsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDocumentsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyDocumentsResponseDto {
        const json = this.toJSON();
        let result = new GetManyDocumentsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class Documents implements IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    documentOwner: DocumentsDocumentOwner;
    documentOwnerId: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    url: string;

    [key: string]: any;

    constructor(data?: IDocuments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.documentOwner = _data["documentOwner"];
            this.documentOwnerId = _data["documentOwnerId"];
            this.mimeType = _data["mimeType"];
            this.fileName = _data["fileName"];
            this.relativePath = _data["relativePath"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Documents {
        data = typeof data === 'object' ? data : {};
        let result = new Documents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["documentOwner"] = this.documentOwner;
        data["documentOwnerId"] = this.documentOwnerId;
        data["mimeType"] = this.mimeType;
        data["fileName"] = this.fileName;
        data["relativePath"] = this.relativePath;
        data["url"] = this.url;
        return data;
    }

    clone(): Documents {
        const json = this.toJSON();
        let result = new Documents();
        result.init(json);
        return result;
    }
}

export interface IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    documentOwner: DocumentsDocumentOwner;
    documentOwnerId: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    url: string;

    [key: string]: any;
}

export class AuthCredentialDto implements IAuthCredentialDto {
    username: string;
    password: string;

    [key: string]: any;

    constructor(data?: IAuthCredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthCredentialDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthCredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }

    clone(): AuthCredentialDto {
        const json = this.toJSON();
        let result = new AuthCredentialDto();
        result.init(json);
        return result;
    }
}

export interface IAuthCredentialDto {
    username: string;
    password: string;

    [key: string]: any;
}

export class ResetPassword implements IResetPassword {
    email: string;
    token: string;
    password: string;
    code: string;

    [key: string]: any;

    constructor(data?: IResetPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): ResetPassword {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        data["code"] = this.code;
        return data;
    }

    clone(): ResetPassword {
        const json = this.toJSON();
        let result = new ResetPassword();
        result.init(json);
        return result;
    }
}

export interface IResetPassword {
    email: string;
    token: string;
    password: string;
    code: string;

    [key: string]: any;
}

export class ForgotPasswordDto implements IForgotPasswordDto {
    email: string;

    [key: string]: any;

    constructor(data?: IForgotPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        return data;
    }

    clone(): ForgotPasswordDto {
        const json = this.toJSON();
        let result = new ForgotPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordDto {
    email: string;

    [key: string]: any;
}

export class CreateUserDto implements ICreateUserDto {
    userType: number;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    email: string;
    title: string;
    institution: number;
    mrvInstitution: string;
    telephone: string;
    mobile: string;
    nic: string;
    country: number;

    [key: string]: any;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userType = _data["userType"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.institution = _data["institution"];
            this.mrvInstitution = _data["mrvInstitution"];
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.nic = _data["nic"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userType"] = this.userType;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["title"] = this.title;
        data["institution"] = this.institution;
        data["mrvInstitution"] = this.mrvInstitution;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["nic"] = this.nic;
        data["country"] = this.country;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userType: number;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    email: string;
    title: string;
    institution: number;
    mrvInstitution: string;
    telephone: string;
    mobile: string;
    nic: string;
    country: number;

    [key: string]: any;
}

export class ReqUserDto implements IReqUserDto {
    andoprator: string;
    oroprator: string;
    row: any;
    first: any;

    [key: string]: any;

    constructor(data?: IReqUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.andoprator = _data["andoprator"];
            this.oroprator = _data["oroprator"];
            this.row = _data["row"];
            this.first = _data["first"];
        }
    }

    static fromJS(data: any): ReqUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReqUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["andoprator"] = this.andoprator;
        data["oroprator"] = this.oroprator;
        data["row"] = this.row;
        data["first"] = this.first;
        return data;
    }

    clone(): ReqUserDto {
        const json = this.toJSON();
        let result = new ReqUserDto();
        result.init(json);
        return result;
    }
}

export interface IReqUserDto {
    andoprator: string;
    oroprator: string;
    row: any;
    first: any;

    [key: string]: any;
}

export class GetManyInstitutionCategoryResponseDto implements IGetManyInstitutionCategoryResponseDto {
    data: InstitutionCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;

    constructor(data?: IGetManyInstitutionCategoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(InstitutionCategory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyInstitutionCategoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyInstitutionCategoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyInstitutionCategoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyInstitutionCategoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyInstitutionCategoryResponseDto {
    data: InstitutionCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    [key: string]: any;
}

export class InstitutionCategory implements IInstitutionCategory {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;

    constructor(data?: IInstitutionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
        }
    }

    static fromJS(data: any): InstitutionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        return data;
    }

    clone(): InstitutionCategory {
        const json = this.toJSON();
        let result = new InstitutionCategory();
        result.init(json);
        return result;
    }
}

export interface IInstitutionCategory {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;

    [key: string]: any;
}

export class CreateIndicatorDto implements ICreateIndicatorDto {

    [key: string]: any;

    constructor(data?: ICreateIndicatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CreateIndicatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIndicatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): CreateIndicatorDto {
        const json = this.toJSON();
        let result = new CreateIndicatorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateIndicatorDto {

    [key: string]: any;
}

export class UpdateIndicatorDto implements IUpdateIndicatorDto {

    [key: string]: any;

    constructor(data?: IUpdateIndicatorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): UpdateIndicatorDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIndicatorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }

    clone(): UpdateIndicatorDto {
        const json = this.toJSON();
        let result = new UpdateIndicatorDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateIndicatorDto {

    [key: string]: any;
}

export enum CountryStatus {
    Active = <any>"Active",
    Deactivated = <any>"Deactivated",
}

export enum MethodologyIsActive {
    Active = <any>"Active",
    DeActive = <any>"DeActive",
}

export enum DocumentsDocumentOwner {
    Project = <any>"Project",
    Country = <any>"Country",
    LearningMaterial = <any>"LearningMaterial",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}